<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>kafka</title>
    <link href="/2025/05/22/mq/kafka/"/>
    <url>/2025/05/22/mq/kafka/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p>kafka的组成部分：</p><ul><li>消息系统：和传统的消息中间件一样，都具有系统解耦，冗余存储，流量削峰，缓冲，异步通信等功能；</li><li>存储系统：持久化</li><li>流式处理平台</li></ul><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><ul><li>Producer：生产者,发送kafka消息到对应的broker</li><li>Consumer：消费者，从broker中消费消息（pull模式）<ul><li>Consumer Group：快速消费</li></ul></li><li>Broker：服务节点</li><li>Controller：元数据管理<ul><li>管理Partition的Leader选举，副本同步</li></ul></li><li>Zookeeper&#x2F;KRaft：集群元数据协调<ul><li>保存Broker信息，Partition位置，控制器选举</li><li>KRaft不需要zookeeper</li></ul></li><li>Topic：逻辑概念，消息的主题（分类）（包含多个Partition）</li><li>Partition：逻辑概念，分区（<strong>主从机制核心</strong>）<ul><li>每个partition有一个Leader，多个Follower副本</li></ul></li></ul><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="DESCRIPTION" height="465px" preserveAspectRatio="none" style="width:681px;height:465px;background:#FFFFFF;" version="1.1" viewBox="0 0 681 465" width="681px" zoomAndPan="magnify"><title>Kafka &#26550;&#26500;&#22270;&#65288;KRaft &#27169;&#24335;&#65289;</title><defs/><g><g class="title" data-source-line="1"><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="196.7515" x="235.1892" y="22.9951">Kafka &#26550;&#26500;&#22270;&#65288;KRaft &#27169;&#24335;&#65289;</text></g><!--cluster Kafka Cluster--><g class="cluster" data-entity="Kafka Cluster" data-source-line="16" data-uid="ent0004" id="cluster_Kafka Cluster"><path d="M216.63,191.9669 L324.1134,191.9669 A3.75,3.75 0 0 1 326.6134,194.4669 L333.6134,214.2638 L671.63,214.2638 A2.5,2.5 0 0 1 674.13,216.7638 L674.13,456.3069 A2.5,2.5 0 0 1 671.63,458.8069 L216.63,458.8069 A2.5,2.5 0 0 1 214.13,456.3069 L214.13,194.4669 A2.5,2.5 0 0 1 216.63,191.9669" fill="#EEE8D5" style="stroke:#000000;stroke-width:1.5;"/><line style="stroke:#000000;stroke-width:1.5;" x1="214.13" x2="333.6134" y1="214.2638" y2="214.2638"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="106.4834" x="218.13" y="206.962">Kafka Cluster</text></g><!--cluster Topic: orders--><g class="cluster" data-entity="Topic: orders" data-source-line="22" data-uid="ent0008" id="cluster_Topic: orders"><path d="M337.63,234.9669 L442.6661,234.9669 A3.75,3.75 0 0 1 445.1661,237.4669 L452.1661,257.2637 L647.63,257.2637 A2.5,2.5 0 0 1 650.13,259.7637 L650.13,345.3669 A2.5,2.5 0 0 1 647.63,347.8669 L337.63,347.8669 A2.5,2.5 0 0 1 335.13,345.3669 L335.13,237.4669 A2.5,2.5 0 0 1 337.63,234.9669" fill="#EEE8D5" style="stroke:#000000;stroke-width:1.5;"/><line style="stroke:#000000;stroke-width:1.5;" x1="335.13" x2="452.1661" y1="257.2637" y2="257.2637"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="104.0361" x="339.13" y="249.962">Topic: orders</text></g><!--entity B1--><g class="entity" data-entity="B1" data-source-line="18" data-uid="ent0005" id="entity_B1"><rect fill="#FDF6E3" height="47.9375" rx="2.5" ry="2.5" style="stroke:#000000;stroke-width:0.5;" width="151.9121" x="476.18" y="394.8669"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="51.2227" x="486.18" y="416.0055">Broker 1</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="131.9121" x="486.18" y="429.9743">(Leader of Partition 0)</text></g><!--entity B2--><g class="entity" data-entity="B2" data-source-line="19" data-uid="ent0006" id="entity_B2"><rect fill="#FDF6E3" height="47.9375" rx="2.5" ry="2.5" style="stroke:#000000;stroke-width:0.5;" width="151.9121" x="269.18" y="394.8669"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="51.2227" x="279.18" y="416.0055">Broker 2</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="131.9121" x="279.18" y="429.9743">(Leader of Partition 1)</text></g><!--entity B3--><g class="entity" data-entity="B3" data-source-line="20" data-uid="ent0007" id="entity_B3"><rect fill="#FDF6E3" height="47.9375" rx="2.5" ry="2.5" style="stroke:#000000;stroke-width:0.5;" width="86" x="230.13" y="276.9469"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="51.2227" x="240.13" y="298.0855">Broker 3</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="66" x="240.13" y="312.0543">(Followers)</text></g><!--entity Part0--><g class="entity" data-entity="Part0" data-source-line="23" data-uid="ent0009" id="entity_Part0"><rect fill="#FDF6E3" height="61.9063" rx="2.5" ry="2.5" style="stroke:#000000;stroke-width:0.5;" width="123.8574" x="510.2" y="269.9669"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="61.998" x="520.2" y="291.1055">Partition 0</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="65.0801" x="520.2" y="305.0743">Leader: B1</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="103.8574" x="520.2" y="319.043">Followers: B2, B3</text></g><!--entity Part1--><g class="entity" data-entity="Part1" data-source-line="24" data-uid="ent0010" id="entity_Part1"><rect fill="#FDF6E3" height="61.9063" rx="2.5" ry="2.5" style="stroke:#000000;stroke-width:0.5;" width="123.8574" x="351.2" y="269.9669"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="61.998" x="361.2" y="291.1055">Partition 1</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="65.0801" x="361.2" y="305.0743">Leader: B2</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="103.8574" x="361.2" y="319.043">Followers: B1, B3</text></g><!--entity P--><g class="entity" data-entity="P" data-source-line="13" data-uid="ent0002" id="entity_P"><ellipse cx="450.1349" cy="56.4869" fill="#F1F1F1" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M450.1349,64.4869 L450.1349,91.4869 M437.1349,72.4869 L463.1349,72.4869 M450.1349,91.4869 L437.1349,106.4869 M450.1349,91.4869 L463.1349,106.4869" fill="none" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="62.5898" x="418.84" y="120.982">Producer</text></g><!--entity CG--><g class="entity" data-entity="CG" data-source-line="14" data-uid="ent0003" id="entity_CG"><ellipse cx="577.1338" cy="56.4869" fill="#F1F1F1" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M577.1338,64.4869 L577.1338,91.4869 M564.1338,72.4869 L590.1338,72.4869 M577.1338,91.4869 L564.1338,106.4869 M577.1338,91.4869 L590.1338,106.4869" fill="none" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="118.7676" x="517.75" y="120.982">Consumer Group</text></g><!--entity Ctrl--><g class="entity" data-entity="Ctrl" data-source-line="28" data-uid="ent0011" id="entity_Ctrl"><rect fill="#FDF6E3" height="47.9375" rx="2.5" ry="2.5" style="stroke:#000000;stroke-width:0.5;" width="166.5664" x="13.85" y="62.1669"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="95.5957" x="23.85" y="83.3055">KRaft Controller</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="146.5664" x="23.85" y="97.2743">(Raft metadata quorum)</text></g><g class="entity" data-entity="GMN21" data-source-line="44" data-uid="ent0022" id="entity_GMN21"><path d="M215.46,43.2969 L215.46,82.1269 L180.7,86.1269 L215.46,90.1269 L215.46,128.9609 A0,0 0 0 0 215.46,128.9609 L376.8067,128.9609 A0,0 0 0 0 376.8067,128.9609 L376.8067,53.2969 L366.8067,43.2969 L215.46,43.2969 A0,0 0 0 0 215.46,43.2969" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M366.8067,43.2969 L366.8067,53.2969 L376.8067,53.2969 L366.8067,43.2969" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="133.8403" x="221.46" y="60.3638">Replaces ZooKeeper</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="56.9956" x="221.46" y="75.4966">Handles:</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="128.8447" x="221.46" y="90.6294">- Controller election</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="122.1035" x="221.46" y="105.7622">- Cluster metadata</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="140.3467" x="221.46" y="120.895">- Topic/partition state</text></g><!--link P to Part0--><g class="link" data-entity-1="P" data-entity-2="Part0" data-source-line="30" data-uid="lnk12" id="link_P_Part0"><path d="M471.66,124.6869 C495.33,165.9669 529.9054,226.2719 551.7754,264.4119" fill="none" id="P-to-Part0" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="554.76,269.6169,553.7531,259.8196,552.2728,265.2794,546.8131,263.7991,554.76,269.6169" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="41.4058" x="501.13" y="172.0338">send()</text></g><!--link P to Part1--><g class="link" data-entity-1="P" data-entity-2="Part1" data-source-line="31" data-uid="lnk13" id="link_P_Part1"><path d="M433.75,124.5369 C429.61,135.4469 425.64,147.5069 423.13,158.9669 C414.94,196.4669 413.07,234.7971 412.83,263.5871" fill="none" id="P-to-Part1" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="412.78,269.5869,416.8549,260.6205,412.8217,264.587,408.8552,260.5538,412.78,269.5869" style="stroke:#181818;stroke-width:1;"/></g><!--link Part0 to B1--><g class="link" data-entity-1="Part0" data-entity-2="B1" data-source-line="33" data-uid="lnk14" id="link_Part0_B1"><path d="M566.93,332.0669 C563.57,351.5269 560.2905,370.5443 557.1905,388.5043" fill="none" id="Part0-to-B1" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="556.17,394.4169,561.6425,386.2284,557.0205,389.4897,553.7591,384.8677,556.17,394.4169" style="stroke:#181818;stroke-width:1;"/></g><!--link Part1 to B2--><g class="link" data-entity-1="Part1" data-entity-2="B2" data-source-line="34" data-uid="lnk15" id="link_Part1_B2"><path d="M395.44,332.0669 C384.03,351.5269 372.4468,371.2822 361.9068,389.2422" fill="none" id="Part1-to-B2" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="358.87,394.4169,366.8751,388.6794,361.4007,390.1046,359.9754,384.6303,358.87,394.4169" style="stroke:#181818;stroke-width:1;"/></g><!--link CG to Part0--><g class="link" data-entity-1="CG" data-entity-2="Part0" data-source-line="36" data-uid="lnk16" id="link_CG_Part0"><path d="M576.25,124.6869 C575.28,165.9669 573.88,225.4785 572.99,263.6185" fill="none" id="CG-to-Part0" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="572.85,269.6169,577.0589,260.7126,572.9666,264.6182,569.061,260.526,572.85,269.6169" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="33.5728" x="576.13" y="172.0338">poll()</text></g><!--link CG to Part1--><g class="link" data-entity-1="CG" data-entity-2="Part1" data-source-line="37" data-uid="lnk17" id="link_CG_Part1"><path d="M548.82,124.4569 C535.65,140.9169 519.33,160.0869 503.13,175.9669 C499.07,179.9469 497.01,179.7969 493.13,183.9669 C468.46,210.4469 448.7017,239.9429 433.7817,264.4329" fill="none" id="CG-to-Part1" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="430.66,269.5569,438.7585,263.952,433.2614,265.2869,431.9265,259.7898,430.66,269.5569" style="stroke:#181818;stroke-width:1;"/></g><!--reverse link Ctrl to B1--><g class="link" data-entity-1="Ctrl" data-entity-2="B1" data-source-line="39" data-uid="lnk18" id="link_Ctrl_B1"><path d="M88.5247,116.1264 C74.4247,167.9464 50.79,288.0069 115.13,355.8669 C164.88,408.3369 366.75,383.3869 438.13,394.8669 C450.39,396.8369 463.34,399.1869 475.94,401.6269" fill="none" id="Ctrl-backto-B1" style="stroke:#181818;stroke-width:1;stroke-dasharray:7.0,7.0;"/><polygon fill="#181818" points="90.1,110.3369,83.8774,117.9709,88.7872,115.1615,91.5967,120.0713,90.1,110.3369" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="96.9922" x="116.13" y="305.4838">metadata sync</text></g><!--reverse link Ctrl to B2--><g class="link" data-entity-1="Ctrl" data-entity-2="B2" data-source-line="40" data-uid="lnk19" id="link_Ctrl_B2"><path d="M81.0587,115.5922 C54.9087,164.6722 6,275.9269 54.13,355.8669 C76.08,392.3269 190.3,407.5169 268.94,413.7269" fill="none" id="Ctrl-backto-B2" style="stroke:#181818;stroke-width:1;stroke-dasharray:7.0,7.0;"/><polygon fill="#181818" points="83.88,110.2969,76.1178,116.3589,81.5289,114.7096,83.1782,120.1207,83.88,110.2969" style="stroke:#181818;stroke-width:1;"/></g><!--reverse link Ctrl to B3--><g class="link" data-entity-1="Ctrl" data-entity-2="B3" data-source-line="41" data-uid="lnk20" id="link_Ctrl_B3"><path d="M131.8186,114.3826 C154.3186,132.8426 180.37,156.2069 203.13,183.9669 C227.44,213.5969 249.17,252.5069 261.75,276.8569" fill="none" id="Ctrl-backto-B3" style="stroke:#181818;stroke-width:1;stroke-dasharray:7.0,7.0;"/><polygon fill="#181818" points="127.18,110.5769,131.6008,119.3778,131.0455,113.7483,136.675,113.193,127.18,110.5769" style="stroke:#181818;stroke-width:1;"/></g><!--SRC=[TLAnRjim4Dtv5GTtIO0wYMGqA8mYWnNR1Tp1I3iLNbZfx0YcIVL8eMWBRntQAHzG842tV44detyJh_c57iL4eG4Rq22-k_VktIDTwHJ2HCwN4hQtVxUtF-v__tlO_9nSoRc3xTsV-ytDm-QN47PPwagIN05XxgHUCEsx01Z8VBaWK-iYCyeGl1XTZiw7FLynL205z9FYDiP6HhltvJU491NhIBFYibmSK1mEXwylN-rLN0iXSyV7pfHCKUT87P0MfazePhIjLqWmPi6ggMLZ8Px6TSBYcQgjyrG_dh_d3Ji3Cakc9pDzz0ubJmSpXwaaLxhIQ3WxRZG7oLvMUe2LFBBIlQmUiqP6AVC5oJvszWItjgu_cAhC-z2aOOFh7Q78tqm70ttsEDEjB1_JbomRqkBsiyCQIQIHxceaEne-XBM_aaWcl2E-1aVCG-BT6cI5JXRIIVXS6wfNOStCaH9Y2jtkHJ05VR2eYwFZ24ouewbvW8Dli718XSZ6E-oAXp8xGfdkny2RanDcSqlhn7xLULHBet-ENnk7GENYslcxR9nUOSMF42ryD6Q2M269jr8N2crVTAET0HK7mb5wD3orTYf3pMsULctUrac7WjS6F_C_]--></g></svg><p>说明：</p><ul><li>Producer 向不同的partition发送消息</li><li>不同的partition分配到不同的Broker上，每个Partition有一个Leader负责读写；</li><li>Consumer订阅Topic的Partition并从中消费消息；</li><li>ZooKeeper&#x2F;KRaft 负责元数据管理，选主和集群协调；</li></ul><h2 id="多副本机制"><a href="#多副本机制" class="headerlink" title="多副本机制"></a>多副本机制</h2><p>通过增加副本数量，提高容灾能力；同一分区的不同副本中保存的是相同的消息（在同一时刻，副本之间并非完全一样），副本之间是一主多从的关系，其中 leader 副本负责处理读写请求，follower 副本只负责与 leader 副本的消息同步。</p><p>副本处于不同的 broker 中，当 leader 副本出现故障时，从 follower 副本中重新选举新的 leader 副本对外提供服务。</p><p>Kafka 通过多副本机制实现了故障的自动转移，当 Kafka 集群中某个 broker 失效时仍然能保证服务可用。</p><p>副本分类：</p><ul><li>AR（Assigned Replicas）：所有副本</li><li>ISR（In-Sync Replicas）：一定程度同步的副本</li><li>OSR（Out-of-Sync Replicas）：滞后过多的副本</li></ul><p>Leader副本负责维护和跟踪其他副本的状态，根据情况调整ISR集合和OSR集合；</p><p>当Leader副本发生故障时，只有在ISR集合中的副本有资格被选举为新的Leader；（可通过参数调整）</p><p>ISR 与 HW（High Watermark）和 LEO（LogEndOffset）关系：</p><ul><li>HW（High Watermark）：标记Consumer的可消费区间为 [:HW)，不包含HW位置；</li><li>LEO（LogEndOffset）：下一条消息的写入位置偏移量；</li></ul><h2 id="Kafka同步机制"><a href="#Kafka同步机制" class="headerlink" title="Kafka同步机制"></a>Kafka同步机制</h2><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li>副本同步机制<ul><li>Partition将Leader数据同步到Follower</li><li>replication + ISR 机制</li></ul></li><li>生产者写入同步<ul><li>写入是否等待副本确认</li><li>acks 设置的值：<ul><li>0 异步，不等待响应</li><li>1 只等待Leader写成功</li><li>all&#x2F;-1 等待所有的ISR副本写成功</li></ul></li></ul></li><li>日志落盘同步<ul><li>写入磁盘是否强制刷盘</li><li>默认页缓存，不立即刷盘，提高性能</li><li>配置 <ul><li><code>flush.messages</code>:多少消息刷一次磁盘</li><li><code>flush.ms</code>：多少ms刷一次磁盘</li></ul></li></ul></li><li>消费者Offset提交同步<ul><li>消费者消费后的offset是否同步提交</li><li>配置：<ul><li><code>enable.auto.commit</code>:自动提交</li><li><code>auto.commit.interval.ms</code>:自动提交间隔</li></ul></li></ul></li></ul><h2 id="分区数的设定"><a href="#分区数的设定" class="headerlink" title="分区数的设定"></a>分区数的设定</h2><p>根据实际的业务场景，软硬件条件进行具体的考量；</p><p>分区是 Kafka 中最小的并行操作单元，对生产者而言，每一个分区的数据写入是完全可以并行化的；<br>对消费者而言，Kafka 只允许单个分区中的消息被一个消费者线<br>程消费，一个消费组的消费并行度完全依赖于所消费的分区数；</p><ul><li>并发单位（Consumer Group内并发消费的数量）</li><li>吞吐单位（Producter 可以并发写入多个分区）</li><li>伸缩单位（迁移，重分配都是按照分区操作）</li></ul><p>估算partition的实用公式：<br><code>partition 数量 = consumer（实例数）* 每个实例最大并发 * 安全系数（1.5～2）</code></p><h3 id="高性能原因"><a href="#高性能原因" class="headerlink" title="高性能原因"></a>高性能原因</h3><ul><li>批处理<ul><li>聚合消息，降低调用次数（传递的开销）</li></ul></li><li>日志格式改进 + 编码改进<ul><li>Varints和ZigZag编码，提升网络的传输效率</li></ul></li><li>消息压缩<ul><li>减少网络传输量，降低网络IO，使用时间换空间；</li></ul></li><li>索引<ul><li>独立的索引文件，快速查询</li></ul></li><li>分区<ul><li>分布式来降低单个实例的压力</li></ul></li><li>顺序写入<ul><li>追加顺序写入，提高吞吐</li></ul></li><li>页缓存<ul><li>使用页缓存加速数据查询</li></ul></li><li>零拷贝（Zero Copy）<ul><li>（sendfile 系统调用在 Linux 内核版本 2.1 中被引入，目的是简化通过网络在两个通道之间进行的数据传输过程。sendfile 允许操作系统从 Page Cache 直接将文件发送至 socket 缓存区，节省了内核空间 &amp; 用户空间的两次冗余的 cpu 拷贝操作，最后只需要通过 DMA 传输将数据复制到网卡。</li><li>使得调用变得更加简洁：不仅减少了 CPU 拷贝的次数，由于文件传输拷贝仅发生在内核空间，还减少了上下文切换的次数。）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>mq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mq</tag>
      
      <tag>kafka</tag>
      
      <tag>高性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统设计基础理论-CAP，BASE</title>
    <link href="/2025/05/12/distributed/theory/"/>
    <url>/2025/05/12/distributed/theory/</url>
    
    <content type="html"><![CDATA[<h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p>CAP 理论是分布式系统设计的基础理论之一</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>核心：在一个分布式系统中，最多只能同时满足以下三个目标中的两个；</p><ul><li>Consistency: 强一致性<ul><li>所有节点在同一时间看到的数据必须一致。 如同一个单机系统，读写都一致。</li></ul></li><li>Availability: 可用性<ul><li>非故障的节点在合理的时间内返回合理的响应（无论结果是否正确）</li></ul></li><li>Partition tolerance: 分区容错性<ul><li>系统能容忍任意节点之间的通信失败（网络分区）</li></ul></li></ul><h2 id="取舍"><a href="#取舍" class="headerlink" title="取舍"></a>取舍</h2><p>对于分布式系统，网络无法做到100%可靠，有可能出现故障，因此分区容错是一个必须的选项（P必须满足）；</p><ul><li>CA 架构无法选择的原因：出现网络分区，为了保证C（数据一致性），同时时间就不能让所有节点进行读写操作（违反了A）</li><li>CP 架构：强一致的使用场景，etcd，consul，zookeeper，hbase就是CP架构</li><li>AP 架构：高可用的场景，cassandra，eureka就是AP架构，Nacos支持CP架构也支持AP架构；</li></ul><p>网络未发生分区时（系统大部分状态），一致性（C）和可用性（A）通常可以同时得到满足；CAP理论的权衡选择主要是在网络分区（P）实际发生时才变得至关重要。因此，在系统设计中，当网络分区未发生时，我们依然可以追求高一致性和高可用性。”</p><h1 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h1><p>BASE 理论是对 CAP 理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency），但应用可以采用适合的方式达到最终一致性（Eventual Consistency）。</p><p>BASE 理论是实践工程的理论，它弥补了CAP 理论过于抽象的问题，也同时解决了 AP 系统的总体工程实践思想，是分布式系统的核心理论之一</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ul><li>在分布式系统中，特别是在选择了分区容错（P）的前提下，如果优先保证可用性（A），往往难以同时满足强一致性（C）。因此，BASE理论提出采用适当的方式，使系统能够达到最终一致性。</li><li>是对于AP方案的补充，不保证线性一致性保证最终一致性</li><li>AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。<ul><li>在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方；</li></ul></li></ul><h2 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h2><ul><li>Basic-Available 基本可用<ul><li>分布式系统出现不可预知的故障时，允许损失部分可用性（不等价于系统不可用）<ul><li>响应时间的损失：慢</li><li>系统功能上的损失：降级</li></ul></li></ul></li><li>Soft-State 软状态<ul><li>允许系统中的数据存在中间状态（CAP理论中的数据不一致），并且认为该状态存在不会影响系统的整体可用性，主副本之间数据同步的延迟就是软状态的一种体现；</li></ul></li><li>Eventually-Consistency 最终一致性<ul><li>系统中的所有数据副本，在<strong>一段时间</strong>后，最终能够达到一个一致的状态；</li><li>实现最终一致性的方法：<ul><li>读时修复：读取数据时，检测数据的不一致，进行修复，检测不同副本的数据不一致，系统自动修复；</li><li>写时修复：写入数据时，系统尝试检测并修复数据的不一致性，但是可能会对写操作的性能带来一定影响；</li><li>异步修复：定时检测副本数据的一致性，进行修复；</li></ul></li></ul></li></ul><p>BASE 理论实质上是对 CAP 理论中 AP 选择的一种深化和实践指导。它承认在追求高可用性和分区容错性的分布式系统中，强一致性可能难以时刻保证，因此提出了一套实现最终一致性的设计哲学和方法，从而在一定程度上放宽了对系统实时一致性的严苛要求。</p>]]></content>
    
    
    <categories>
      
      <category>distributed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>distributed</tag>
      
      <tag>CAP</tag>
      
      <tag>BASE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>共识算法</title>
    <link href="/2025/05/12/distributed/consensus/"/>
    <url>/2025/05/12/distributed/consensus/</url>
    
    <content type="html"><![CDATA[<h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><p>“共识算法”（Consensus Algorithm）是分布式系统中用来就某个数据或状态达成一致的机制。</p><p>它的核心目标是在多个节点之间，即便部分节点可能故障或作恶（拜占庭行为），也能让整个系统达成对某个值或决策的一致认可；</p><h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p>多数派原则:Acceptor需要超过半数的 Acceptor 同意;</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>Proposer 提案者：提出提案，包含提案编号和提案的值；</li><li>Acceptor 接收者： 投票接受建议，决定最终值；</li><li>Learner 学习者：学习被接受的值，最终结果；</li></ul><h3 id="决议过程"><a href="#决议过程" class="headerlink" title="决议过程"></a>决议过程</h3><ol><li>Prepare阶段：Proposer 向 Acceptor 发送 Prepare请求，Acceptors 针对收到的Prepare请求进行Promise承诺；<ul><li>两个承诺：</li><li>不再接受Proposal ID 小于等于(&lt;&#x3D;) 当前请求的Prepare请求</li><li>不再接受Proposal ID 小于(&lt;) 当前请求的Propose请求</li></ul></li><li>Acceptor阶段: Proposer 收到多数Acceptor承诺的Promise后，向Acceptors发出Propose请求，Acceptors针对收到的Propose请求进行Accept处理；</li><li>Learn阶段：Proposer在收到多数Acceptors的Accept之后，标志着本次Accept成功，决议形成，将形成的决议发送给所有Learners;</li></ol><h3 id="问题：活锁"><a href="#问题：活锁" class="headerlink" title="问题：活锁"></a>问题：活锁</h3><ul><li>两个提案Proposer交替prepare成功，而Accept失败</li><li>两个提案不断交替Prepare（两个都不能得到更多的Promise)，导致无法Accept成功；</li></ul><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>Raft是一种用于替代Paxos的共识算法，<font color='red'>基于日志复制的方式复制状态机达到同步数据的目的</font>。</p><p>相比于Paxos，Raft的目标是提供更清晰的逻辑分工使得算法本身能被更好地理解，同时它安全性更高，并能提供一些额外的特性；</p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>保证每个节点的日志一致性，各个节点基于相同的日志，顺序执行命令，达到数据的一致性，将<strong>数据一致性</strong>转化为<strong>日志一致性</strong>，简化问题；</p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><h4 id="节点角色"><a href="#节点角色" class="headerlink" title="节点角色"></a>节点角色</h4><ul><li>Leader<ul><li>领导者， 唯一负责接受客户端请求，复制日志给其他节点，任期中只能存在一个Leader</li><li>NOTE：任期（将时间分为一个个的任期（term），每一个term的开始都是Leader选举）<ul><li>每一个任期以一次选举作为起点，所以当一个结点成为 Candidate 并向其他结点请求投票时，会将自己的 Term 加 1，表明新一轮的开始以及旧 Leader 的任期结束。所有结点在收到比自己更新的 Term 之后就会更新自己的 Term 并转成 Follower，而收到过时的消息则拒绝该请求</li><li>在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束</li></ul></li></ul></li><li>Candidate<ul><li>候选者，竞选Leader的节点</li></ul></li><li>Follower<ul><li>被动响应来自Leader或者候选者的节点</li></ul></li></ul><h4 id="日志复制-类似单阶段提交-日志补偿"><a href="#日志复制-类似单阶段提交-日志补偿" class="headerlink" title="日志复制(类似单阶段提交+日志补偿)"></a>日志复制(类似单阶段提交+日志补偿)</h4><ol><li>Leader选出后，开始接受客户端请求；</li><li>Leader将请求作为日志条目（log entries）加入日志当中，然后并行的向其他服务器发起<code>AppendEntries RPC</code> 复制日志条目；</li><li>当日志被复制到多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。<ul><li>日志组成：有序编号(log index) 的日志条目组成，每个日志条目包含它被创建时的任期号（term），和用于状态机执行的命令。</li><li>如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了</li></ul></li></ol><h5 id="心跳-AppendEntries-RPC"><a href="#心跳-AppendEntries-RPC" class="headerlink" title="心跳(AppendEntries RPC)"></a>心跳(<code>AppendEntries RPC</code>)</h5><ul><li>Leader负责接收客户端的请求（提案）</li><li><font color='red'>提案</font>内容被包含在同步给Follower的下一次心跳中(提案(可能存在多个))，Follower接受到心跳后回复;</li><li>Leader 接收到多数派 Follower 的回复后，确认提案写入存储中（提交，应用到状态机），回复Client结果；</li><li>Leader 通知Follower节点确认提案并写入自己的存储空间（应用状态机）</li></ul><h6 id="要点"><a href="#要点" class="headerlink" title="要点"></a><font color='red'>要点</font></h6><ul><li>Follower会检查提案的Term，不一致，拒绝请求；（确保一个Leader）</li><li>Leader不会删除自己的日志，只会追加；</li><li>所有Follower的同步情况由Leader维护；</li><li>投票的过程中每个节点都会与candidate比较日志的最后index以及相应的term，如果要成为Leader，必须有更大的index或者更新的term，所以Leader上肯定有commit过的消息</li></ul><h4 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h4><ol><li>每个Follower都有一个定时器，一段时间后，若集群中不存在Leader节点，增加任期号，Follower变为Candidate，参与Leader选举</li><li>Candidate为自己投票后，发送消息给其他节点，争取同意自身为Leader，每个节点只会同意最早到达的申请；其余节点长时间未响应，会重新发送消息</li><li>多数派支持的Candidate成为Leader</li><li>Leader失联时，未收到Leader心跳的Follower成为Candidate，开始新一轮选举</li></ol><h4 id="日志结构"><a href="#日志结构" class="headerlink" title="日志结构"></a>日志结构</h4><table><thead><tr><th align="center">字段</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">index</td><td align="center">日志索引</td></tr><tr><td align="center">term</td><td align="center">任期</td></tr><tr><td align="center">command</td><td align="center">客户端请求命令</td></tr></tbody></table><h4 id="状态机和提交"><a href="#状态机和提交" class="headerlink" title="状态机和提交"></a>状态机和提交</h4><p>日志条目一旦在大多数节点上复制成功并提交（commit），</p><p>所有节点都会按顺序将日志应用到状态机；</p><p>保证了 线性一致性（Linearizability）。</p><h4 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h4><p>每个节点会将以下状态持久化存储在磁盘中，以便宕机恢复：</p><table><thead><tr><th>状态</th><th>用途</th></tr></thead><tbody><tr><td>currentTerm</td><td>当前任期号</td></tr><tr><td>votedFor</td><td>当前任期已投票给的候选者</td></tr><tr><td>log[]</td><td>日志条目数组（包含 command、term 等）</td></tr></tbody></table><h4 id="快照（snapshot）和日志压缩（log-compaction）"><a href="#快照（snapshot）和日志压缩（log-compaction）" class="headerlink" title="快照（snapshot）和日志压缩（log compaction）"></a>快照（snapshot）和日志压缩（log compaction）</h4><p>为避免日志过长：</p><ul><li>节点会定期生成快照（snapshot）；</li><li>丢弃旧日志，提高效率与恢复速度。</li></ul><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Raft 协议通过一组明确的机制来保证分布式系统中日志复制的一致性和系统状态的安全性，使得在面对网络分区、节点宕机等情况时，系统始终能够避免错误地提交或回滚数据；</p><ul><li><p>Leader Completeness （领导完整性）</p><blockquote><p>如果一个日志条目在某个任期（term）被提交了，那么在该任期之后任何被选举出来的领导者都至少包含该条目。</p></blockquote><ul><li>一个Leader任期内，只能提交任期内的日志；</li><li>保证一旦某个日志条目被“提交”，它不会在后续被领导者删除或回滚。</li><li>选举时，候选人必须拥有“最新”的日志才能赢得选举，确保新选出的领导人日志至少包含所有已提交条目；</li></ul></li><li><p>Log Matching Property (日志匹配性)</p><blockquote><p>如果两个日志在相同的索引位置拥有相同的任期（term），那么它们之前的所有日志也都相同</p></blockquote><ul><li>保证日志复制的前缀一致性，防止错位写入</li><li>实现：<ul><li>在 <code>AppendEntries</code> RPC 中， Follower会验证：<ul><li><code>prevLogIndex</code> 和 <code>prevLogTerm</code> 必须与 Follower 本地日志中最后一个条目的索引和任期号匹配；</li><li>如果不匹配，Follower 会拒绝 <code>AppendEntries</code> 请求，Leader 会回退日志并重试。</li></ul></li></ul></li><li>这样，Leader会不断回退重试，直到找到一个匹配的索引位置，然后开始复制日志；</li></ul></li><li><p>Election Safety（选举安全性）</p><blockquote><p>在同一任期内，最多只能有一个领导者被选出。</p></blockquote><ul><li>防止多主问题，导致日志并行写入，冲突和不一致；</li><li>实现<ul><li>每个节点在一个任期内最多只能投票给一个候选人；</li><li>候选人必须拥有最新的日志才能赢得大多数选票</li></ul></li></ul></li><li><p>State Machine Safty（状态机器安全性）</p><blockquote><p>如果某个节点应用了某条日志记录（即提交到状态机），其他所有节点也绝不会在相同位置应用不同的记录。</p></blockquote><ul><li>实现<ul><li>状态机的执行是串行的，不会并发执行；</li><li>由于 Raft 使用前述机制保证提交日志的一致性，所有节点最终状态机输入完全一致 → 强一致性保证</li><li>日志条目一旦被大多数节点确认，即“已提交”，才可以应用到状态机；</li></ul></li></ul></li><li><p>Leader附加机制</p><ul><li>心跳（Heart Beat）：防止旧Leader恢复后写入</li><li>任期号（Term）：每次选举任期号增加哎，防止旧任期Leader继续生效</li><li>集群通过 Term 判断命令的合法性，旧Leader发送的RPC会被忽略</li></ul></li></ul><h2 id="ZAB（zookeeper）"><a href="#ZAB（zookeeper）" class="headerlink" title="ZAB（zookeeper）"></a>ZAB（zookeeper）</h2><p>ZooKeeper 使用的一种<strong>原子广播协议</strong>，用于实现分布式系统中的数据一致性和高可用性。它是 ZooKeeper 的核心协议，保证多个节点在面对网络延迟、宕机、重启等故障时仍能保持一致的状态；</p><p>不采用类似Raft的日志复制机制，而是利用原子广播的协议簇；更加追求的是工程上的高效；</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th>对比项</th><th>ZAB 协议（Zookeeper）</th><th>Raft 协议</th></tr></thead><tbody><tr><td>所属系统</td><td>ZooKeeper</td><td>Etcd、Consul、TiKV、CockroachDB 等</td></tr><tr><td>协议类型</td><td>原子广播协议（Atomic Broadcast）</td><td>日志复制 + 领导选举一致性协议</td></tr><tr><td>设计目标</td><td>高吞吐 + 高可用 + 顺序广播</td><td>易于理解 + 强一致性日志复制</td></tr><tr><td>领导选举</td><td>选 Leader（只能由 Follower 发起）</td><td>选 Leader（由 Candidate 发起）</td></tr><tr><td>日志复制机制</td><td>Leader 广播 proposals，全体 ACK 才提交</td><td>Leader 复制日志，过半节点响应提交</td></tr><tr><td>提交条件</td><td>必须所有“同步”副本 ACK 后才能提交</td><td>只需大多数节点 ACK</td></tr><tr><td>follower 落后处理</td><td>由 Leader 给其发送快照或 diff</td><td>AppendEntries 拉日志补齐</td></tr><tr><td>节点恢复一致方式</td><td>同步整个数据快照，或基于 txnid 增量补发</td><td>基于日志 index + term 增量补发</td></tr><tr><td>网络分区下表现</td><td>较保守：更容易等待全同步节点确认</td><td>容忍延迟节点，只要多数 OK 就提交</td></tr><tr><td>是否更易理解实现</td><td>较复杂，偏工程优化</td><td>设计易懂，形式化证明齐全</td></tr></tbody></table><h2 id="Gossip（redis）"><a href="#Gossip（redis）" class="headerlink" title="Gossip（redis）"></a>Gossip（redis）</h2><ul><li>去中心化，每个节点对等（网状结构）；</li><li>传播复制机制</li><li>Gossip算法每个节点都是对等的，没有角色之分</li><li>Gossip算法中的每个节点都会将数据改动告诉其他节点（类似传八卦）。<ul><li>有话说得好：”最多通过六个人你就能认识全世界任何一个陌生人”，因此数据改动的消息很快就会传遍整个集群。</li></ul></li><li>应用场景：<ul><li>集群成员发现</li><li>故障检测</li><li>最终一致性的数据传播（节点信息同步）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>distributed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>distributed</tag>
      
      <tag>Raft</tag>
      
      <tag>Paxos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化</title>
    <link href="/2025/05/08/redis/performance/"/>
    <url>/2025/05/08/redis/performance/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis的优化"><a href="#Redis的优化" class="headerlink" title="Redis的优化"></a>Redis的优化</h1><h2 id="slowLog的获取"><a href="#slowLog的获取" class="headerlink" title="slowLog的获取"></a>slowLog的获取</h2><p>慢日志查询是优化redis性能的重要手段；</p><ul><li>查看最近 N 条慢查询日志：<ul><li>slowlog get N</li></ul></li><li>配置 Slowlog 相关参数 (μs)<ul><li>CONFIG SET slowlog-log-slower-than 10000 (默认 10000 微秒)</li><li>CONFIG SET slowlog-max-len 128 (默认 128 条)</li></ul></li></ul><h2 id="大Key"><a href="#大Key" class="headerlink" title="大Key"></a>大Key</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当redis的字符串类型占用内存过大&#x2F; 其他类型的元素数量过多时；</p><p>参考值（生产环境）：</p><ul><li>string 大于10KB</li><li>hash&#x2F;set&#x2F;zset&#x2F;list等结构元素大于5k，整体内存大于10MB；</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>大key会导致redis 处理阻塞，单线程处理命令，影响redis的性能，大key的操作时间更长；</li><li>导致内存使用不均，集群数据分布不均匀</li><li>操作key能导致阻塞，rename，del 命令(删除使用 unlink 惰性删除)</li><li>Redis 6.0之前网络阻塞，6.0之后使用了网络IO多线程；</li></ul><h3 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h3><ul><li>redis-cli –bigkeys<ul><li>获取实例5种数据类型最大的key（string，hash，list，set，zset）</li><li>问题：<ul><li>信息较少（只有各类型最大的key信息），内容不够精确（例如hash&#x2F;list&#x2F;set&#x2F;zset都是以元素个数衡量大key，但实际上元素个数多不代表占用内存大）</li></ul></li></ul></li><li>redis-rdb-tools 工具，分析rdb文件<ul><li>信息更加详细</li><li>需要离线操作，获取结果的时间较长</li><li>问题：<ul><li>分析rdb文件需要占用大量内存，分析时间较长</li><li>数据安全问题可能需要处理</li></ul></li></ul></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>拆分大key（业务拆分细化，结构拆分）<ul><li>拆分后，每个key的大小都在10KB以内，操作时间更短</li><li>拆分后，数据分布更均匀，集群数据分布更均匀</li></ul></li><li>非必要定时清除，unlink</li><li>对于大文本信息，利用文档型数据库查询</li><li>大key压缩，snappy算法</li></ul><h2 id="热Key"><a href="#热Key" class="headerlink" title="热Key"></a>热Key</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>访问频率高的key</p><p>热点数据：例如：爆款商品，活动商品，秒杀商品等</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>热点key的请求到服务器主机时，因为请求量过大，导致单机主机资源不足；影响正常服务；</p><p>单key请求集群的节点集中，超过单个redis的瓶颈；</p><h3 id="识别："><a href="#识别：" class="headerlink" title="识别："></a>识别：</h3><ul><li>客户端统计上报<ul><li>hook统计</li></ul></li><li>服务器代理层上报<ul><li>单机模式推荐使用 –hotkeys、MONITOR、redis_exporter</li><li>Sentinel 哨兵模式同单机，注意主从切换后统计会变化</li><li>Cluster 模式每个分片独立，需对每个节点单独运行热 key 检查脚本</li><li>Redis 云服务通常提供内建热 key 监控（如 AWS Elasticache Insights）</li></ul></li></ul><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><ul><li>根据场景，增加本地缓存</li><li>key能够分割，就分割，分到不同节点</li><li>客户端限流合并请求</li></ul><h2 id="过期策略和内存淘汰策略"><a href="#过期策略和内存淘汰策略" class="headerlink" title="过期策略和内存淘汰策略"></a>过期策略和内存淘汰策略</h2><h3 id="过期策略：定期删除-过期删除"><a href="#过期策略：定期删除-过期删除" class="headerlink" title="过期策略：定期删除+过期删除"></a>过期策略：定期删除+过期删除</h3><ul><li>定期删除<ul><li>每隔指定时间，随机抽取<strong>（防止饥饿）</strong>一些设置了过期时间的key，检查是否已经过期了，过期就删除，判定定期删除是否已经到达指定时长，达到了就退出定期删除；</li><li>删除比例：每次删除达到一定比例，继续下一轮，否则终止本轮；</li><li>时间限制：如果本轮删除操作已经消耗了较多的时间，则终止本轮操作，避免影响主线程性能；</li></ul></li><li>惰性删除<ul><li>访问时，判断是否过期，过期删除；</li></ul></li><li>相对优点：<ul><li>定时删除：计时器的开销太大</li><li>延迟队列：对象多，内存暴涨，过期时间修改涉及队列修改不够灵活；</li></ul></li></ul><h4 id="如何确定过期时间（用户体验）"><a href="#如何确定过期时间（用户体验）" class="headerlink" title="如何确定过期时间（用户体验）"></a>如何确定过期时间（用户体验）</h4><ul><li>结合缓存容量，缓存命中率决定</li></ul><p>比较：</p><ul><li>增大过期时间：<ul><li>提高命中率</li><li>提升性能</li><li>增加redis的内存消耗</li></ul></li><li>减少过期时间：<ul><li>减少redis的内存消耗</li></ul></li></ul><h3 id="内存淘汰策略："><a href="#内存淘汰策略：" class="headerlink" title="内存淘汰策略："></a>内存淘汰策略：</h3><ul><li>volatile-lru：设置过期时间的key中，lru；</li><li>volatile-ttl：从设置过期时间的key中挑选将要过期的数据；</li><li>volatile-random：从设置过期时间的key中，随机挑选；</li><li>volatile-lfu：设置过期时间的key中，lfu；</li><li>allkeys-lfu：所有的key，lfu；</li><li>allkeys-lru：所有的key，lru；</li><li>allkey-random：所有的key，随机；</li><li>noeviction：禁止驱逐，写入操作报错；</li></ul><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>内存淘汰策略中的lru和lfu是近似的，并不是精确的；</li><li>lru:采样 + 近似淘汰策略,降低性能开销<ul><li>Redis 内部为每个 key 维护一个 LRU 时间戳（最后一次访问时间）；</li><li>当内存超限时，Redis 会随机抽样 N 个 key（默认 5 <code>maxmemory-samples</code>）；</li><li>从中找出最“久未访问”的 key 并淘汰；</li></ul></li><li>lfu:近似计数 + 衰减机制，降低性能开销<ul><li>两个字段 freq + last_access_time</li><li>访问时，freq不一定+1，概率增加，避免无限增长</li><li>Redis 会定期或惰性方式将 key 的 freq 衰减（降低频率），让“冷 key”逐渐被淘汰</li></ul></li></ul><h3 id="NOTE："><a href="#NOTE：" class="headerlink" title="NOTE："></a>NOTE：</h3><p>主从节点中，过期的key访问控制</p><ul><li>3.2版本之前，从库不会判断数据过期；</li><li>3.2版本之后，key值过期主库会发送del删除过期的key值；并且，读从库时，数据已经过期，则会过滤并返回空值（不删除）；会将Expire&#x2F;PExpire改为ExpireAt，PExpireAt，避免因为同步延迟导致的数据不一致</li></ul><h2 id="其他优化性能的方法（根据场景选用）"><a href="#其他优化性能的方法（根据场景选用）" class="headerlink" title="其他优化性能的方法（根据场景选用）"></a>其他优化性能的方法（根据场景选用）</h2><ul><li>缩短键值对的长度</li><li>使用lazy free</li><li>设置过期时间</li><li>禁用阻塞命令  brpop, blpop,brpoplpush, xread block,BZPOPMIN &#x2F; BZPOPMAX(有序集合)-</li><li>pipeline使用</li><li>修改持久化方式；rdb</li><li>调整配置：hash，zset使用ziplist的大小等等</li><li>分布式架构</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>performance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用场景</title>
    <link href="/2025/05/07/redis/scene/"/>
    <url>/2025/05/07/redis/scene/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Redis作为高性能的K-V数据库，最常见的使用方式就是作为缓存；</p><h3 id="缓存系统"><a href="#缓存系统" class="headerlink" title="缓存系统"></a>缓存系统</h3><ul><li>缓存击穿<ul><li>热点key过期，大量请求同时访问数据库，<ul><li>解决方案：互斥锁，异步刷新过期时间&#x2F;不过期</li></ul></li></ul></li><li>缓存穿透<ul><li>查询不存在的数据查询，透传数据库<ul><li>解决方案：<code>bloom filter</code>，重新考虑业务设计问题，非法请求限流</li></ul></li></ul></li><li>缓存雪崩<ul><li>批量的key同时过期，集群部分宕机 的连锁反应<ul><li>解决方案：过期时间加一个随机值</li></ul></li></ul></li></ul><h3 id="缓存模式"><a href="#缓存模式" class="headerlink" title="缓存模式"></a>缓存模式</h3><p>缓存模式：Cache Aside， Read Through， Write Through， Write Back， Singleflight，删除缓存和延迟双删</p><h4 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h4><p>旁路缓存：缓存是独立的数据源，业务方控制顺序</p><ul><li>优先写数据库，保证写成功了，更新缓存，利用过期时间保证最终一致性</li></ul><h4 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read Through"></a>Read Through</h4><p>读穿透：缓存没数据，缓存没数据，缓存代替业务区数据库加工数据</p><ul><li>只管读，不管写，一样还是存在缓存一致性的问题</li><li>亮点：<ul><li>异步方案：缓存同步从数据库加载数据，将数据返回业务，异步更新缓存</li></ul></li></ul><h4 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h4><p>写穿透：写数据只写缓存，缓存会代替业务更新数据库，一般先写数据库，数据库更新成功后，更新缓存；</p><ul><li>只管写，不管读，未解决一致性问题，数据库返回的结果和设置缓存不是原子的；</li><li>亮点：<ul><li>异步：写入缓存和数据库</li><li>写数据库成功，异步刷新缓存</li></ul></li></ul><h4 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write Back"></a>Write Back</h4><p>写入数据，当缓存过期时，才会被刷到数据库；</p><ul><li>问题：<ul><li>缓存崩溃数据会丢失</li></ul></li><li>亮点：<ul><li>当前写操作不会带来一致性问题，并且缓存高可用时，解决了数据一致性的问题；业务只可见缓存；</li><li>一致性表现更好</li></ul></li></ul><h4 id="Refresh-Ahead-CDC-capture-data-change"><a href="#Refresh-Ahead-CDC-capture-data-change" class="headerlink" title="Refresh Ahead: CDC(capture data change)"></a>Refresh Ahead: CDC(capture data change)</h4><p>接口异步刷新缓存模式</p><ul><li>常见策略：<ul><li>写入时更新缓存</li><li>读取时更新缓存</li></ul></li><li>一致性问题：刷新缓存是异步的</li></ul><h4 id="删除缓存："><a href="#删除缓存：" class="headerlink" title="删除缓存："></a>删除缓存：</h4><p>常见，先更数据库，然后删除缓存；</p><p>一致性问题：读线程缓存未命中和写线程冲突的问题；</p><h4 id="延迟双删（并发量不高使用）"><a href="#延迟双删（并发量不高使用）" class="headerlink" title="延迟双删（并发量不高使用）"></a>延迟双删（并发量不高使用）</h4><p>删除缓存之后，隔一定时间再删除一次缓存；</p><ul><li>亮点：<ul><li>解决删除缓存，数据不一致的问题；</li></ul></li><li>问题： <ul><li>降低缓存的命中率；</li></ul></li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li>利用 <code>SET EX NX</code> 实现锁的插入，更新</li><li>使用定时任务实现锁的续期问题（todo）</li><li>使用 lua 脚本实现锁的释放</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>常量定义：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">var (ErrLockNotAcquired       &#x3D; errors.New(&quot;lock not acquired&quot;)ErrUnlockFailed     &#x3D; errors.New(&quot;unlock failed&quot;)ErrUnlockKeyExpired &#x3D; errors.New(&quot;unlock key expired&quot;)luaEvalGetDel       &#x3D; &quot;if redis.call(&#39;get&#39;, KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>结构定义：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">type DistributedMutex struct &#123;Key stringValue string&#x2F;&#x2F; A redis client.Client *redis.Client&#x2F;&#x2F; A option of the lock.Opt *LockerOptions&#x2F;&#x2F; A local lock. 减少redis锁冲突Mutex sync.Mutex&#125;&#x2F;&#x2F; LockerOptions defines some options for the lock.type LockerOptions struct &#123;&#x2F;&#x2F; It also indicates the timeout to obtain a lock.&#x2F;&#x2F; Default: 5sExpiration time.Duration&#x2F;&#x2F; The count of a lock will be retired. When it is zero, it indicates the lock will not be retired.&#x2F;&#x2F; Default: 0RetryCount int&#x2F;&#x2F; The duration of the next time to lock.&#x2F;&#x2F; Default: 100msRetryDelay time.Duration&#125;&#x2F;&#x2F; NewDistributedMutex create a distributed mutex.func NewDistributedMutex(client *redis.Client, key string, opt *LockerOptions) *DistributedMutex &#123;opt.init()return &amp;DistributedMutex&#123;Key:    key,Value:  uuid.NewString(),Client: client,Opt:    opt,&#125;&#125;func (o *LockerOptions) init() *LockerOptions &#123;if o.Expiration &lt; 1 &#123;o.Expiration &#x3D; 5 * time.Second&#125;if o.RetryCount &lt; 0 &#123;o.RetryCount &#x3D; 0&#125;if o.RetryDelay &lt; 1 &#123;o.RetryDelay &#x3D; 100 * time.Millisecond&#125;return o&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>加锁：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; Lock try to acquire a lock.func (d *DistributedMutex) Lock() error &#123;d.Mutex.Lock()defer d.Mutex.Unlock()retryCount :&#x3D; d.Opt.RetryCountfor &#123;ok, err :&#x3D; d.tryLock()if err !&#x3D; nil &#123;return err&#125; else if ok &#123;return nil&#125;if retryCount &lt;&#x3D; 0 &#123;return ErrLockNotAcquired&#125;time.Sleep(d.Opt.RetryDelay)retryCount--&#125;&#125;func (d *DistributedMutex) tryLock() (bool, error) &#123;return d.Client.SetNX(context.Background(), d.Key, d.Value, d.Opt.Expiration).Result()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>解锁：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; Unlock release the lock (use redis eval(luaScript)func (d *DistributedMutex) Unlock() error &#123;res, err :&#x3D; d.Client.Eval(context.Background(), luaEvalGetDel, []string&#123;d.Key&#125;, d.Value).Result()if err &#x3D;&#x3D; RedisNilResult &#123;return ErrUnlockKeyExpired&#125;if err !&#x3D; nil &#123;return err&#125;if n, ok :&#x3D; res.(int64); ok &amp;&amp; n &#x3D;&#x3D; 1 &#123;return nil&#125;return ErrUnlockFailed&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h2><p>思路：<br>sorted set：zset实现</p><p>按照时间和分数进行排序：<br>分割 score 的组成 [score&lt;&lt;n+timestamp]</p><ul><li>前半部分组成实际分数</li><li>后半部分为时间戳（不一定是实际的更新时间戳，可以是一个结束时间和当前时间差值，避免位数占用过多）</li></ul><p>使用lua脚本进行数值的更新，代码简单不在这里写了</p><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p>使用 Bitmap 实现连续签到<br>每个用户每天签到时将该天对应的位设置为 1，未签到为 0。这样可以：</p><ul><li>快速判断某天是否签到；</li><li>快速统计总签到天数；</li><li>高效判断连续签到天数。</li></ul><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>假设每个用户每天签到数据保存在 Redis 的一个 Bitmap 结构中，键名格式如下：</p><p><code>sign:&lt;user_id&gt;:&lt;year_month&gt;</code></p><p># 例如：sign:1001:2025-05<br>每一位 bit 表示当月某一天的签到情况，0 表示未签，1 表示已签。</p><h3 id="签到逻辑"><a href="#签到逻辑" class="headerlink" title="签到逻辑"></a>签到逻辑</h3><ul><li>签到操作<ul><li><code>SETBIT sign:1001:2025-05 6 1</code>     # 用户1001在5月7日签到（从0开始，index 6）</li></ul></li><li>获取是否签到 <ul><li><code>GETBIT sign:1001:2025-05 6</code></li></ul></li><li>统计总签到天数<ul><li><code>BITCOUNT sign:1001:2025-05</code></li></ul></li><li>计算连续签到天数（如从今天往前）</li><li>你需要从今天开始向前遍历 bit 值，直到遇到 0 为止，统计连续 1 的个数。</li><li>用 BITFIELD 命令获取多个位，应用端计算</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>scene</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高可用</title>
    <link href="/2025/04/29/redis/cluster/"/>
    <url>/2025/04/29/redis/cluster/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-高可用（High-Availability）"><a href="#Redis-高可用（High-Availability）" class="headerlink" title="Redis 高可用（High Availability）"></a>Redis 高可用（High Availability）</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>高可用（High Availability）是指系统能够在出现部分组件故障，异常或维护时，依然持续对外提供服务，最大限度减少业务中断时间；</p><p>高可用架构一般通过冗余部署，自动故障转移，健康检查，负载均衡等实现，目标是将系统的可用性指标（如 SLA）提升到 99.99% 或更高；</p><h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><p>分为主节点和从节点，从节点，不提供写服务，只同步主节点数据</p><p>主从复制分为全量复制和增量复制；</p><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>当从节点第一次连接主节点（丢失数据过多，超过主的repl_backlog_buffer命令缓冲区数量）时，会执行全量复制；</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><pre><code class="mermaid">sequenceDiagram;participant A as "主服务器";  participant B as "从服务器";B->>A:从服务器连接主服务器并发送psync[runID][offset]A->>A:bgsave生成快照，并记录期间的写命令A->>B:发送快照B->>B:载入快照A->>B:发送缓存的写命令B->>B:执行写命令</code></pre><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>注意数据量问题，当数据量过大时，全量复制阶段主节点 fork + 保存RDB文件耗时过大，导致从节点长时间接受不到数据超时，主从节点的数据同步同样可能陷入 全量复制→超时导致复制中断→重连→全量复制→超时导致复制中断 的循环中；<ul><li>解决方案：<ul><li>增大repl-timeout，增大超时时间，避免超时导致复制中断；</li></ul></li></ul></li><li>复制写命令缓冲区溢出也会导致这种循环问题<ul><li>解决方案：<ul><li>增大写命令缓冲区大小，避免缓冲区溢出；</li></ul></li></ul></li></ul><h4 id="无磁盘模式"><a href="#无磁盘模式" class="headerlink" title="无磁盘模式"></a>无磁盘模式</h4><p>Redis 的全量复制最初是基于磁盘的：主节点会通过 bgsave 生成 RDB 快照文件，将其写入磁盘，然后再通过网络发送给从节点。<br>从 Redis 4.0 开始，支持了“无磁盘复制”模式（diskless replication），即主节点可以直接将 RDB 数据通过管道流式发送给从节点，无需先落盘到磁盘，减少了磁盘 IO 压力和延迟。</p><p>是否采用无磁盘模式由配置项 repl-diskless-sync 控制，默认仍为基于磁盘模式。</p><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效；</p><h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><pre><code class="mermaid">sequenceDiagram    participant Slave as 从节点    participant Master as 主节点    Slave->>Master: PSYNC &#123;replicationid&#125; &#123;offset&#125;    alt offset有效（增量复制）        Master-->>Slave: 发送复制积压缓冲区(repl_backlog_buffer)中自 offset 起的命令        Slave-->>Master: ACK offset    else offset无效（执行全量复制）        Master-->>Slave: -FULLRESYNC new_replid new_offset        Master->>Slave: 发送RDB快照        Master->>Slave: 发送RDB后积压命令        Slave-->>Master: ACK offset    end</code></pre><ul><li><code>repl_backlog_buffer</code> 定长的环形数组，数组内容满了，从头开始覆盖前面的内容；</li><li>master会记录自身的偏移量(master_repl_offset)和不同slave(slave_repl_offset)的偏移量;断连之后，通过偏移量同步给从节点；<br><br>如果偏移量已经被覆盖，就重新全量同步；</li><li>通过 repid（从节点标识），replication offset 确定对应的偏移量，确认同步的进度</li></ul><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>主节点发生宕机时需要人工切换节点的角色</p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>解决主从模式需要人工切换的问题，通过<strong>故障的自动转移</strong>，实现<strong>高可用</strong>；</p><h3 id="哨兵功能"><a href="#哨兵功能" class="headerlink" title="哨兵功能"></a>哨兵功能</h3><ul><li>监控：不断检查主节点和从节点的健康状态</li><li>自动故障转移：当主节点不能正常工作时，哨兵会自动进行故障转移工作，它会将失效主节点的其中一个从节点升级为新的主节点，让其他从节点改为复制新的主节点；</li><li>配置提供者：客户端初始化时，连接哨兵获取当前Redis服务的主节点地址</li><li>通知：哨兵可以将故障转移的结果发送给客户端</li></ul><h3 id="哨兵通信"><a href="#哨兵通信" class="headerlink" title="哨兵通信"></a>哨兵通信</h3><ul><li>哨兵之间通信：通过发布订阅模式进行通信的 <code>_sentinel_:hello</code> 频道</li><li>哨兵和Redis实例通信：<ul><li>Redis协议（RESP）</li><li>方式：TCP，端口（6379）</li><li>命令：<ul><li><code>PING</code>: 检测主从是否存活</li><li><code>INFO replication</code>：获取主从复制的状态</li><li><code>SUBSCRIBE +switch-master</code>：监听主从切换通知</li><li><code>SENTINEL is-master-down-by-addr</code>：判断主节点是否下线</li></ul></li></ul></li></ul><h3 id="故障转移的过程"><a href="#故障转移的过程" class="headerlink" title="故障转移的过程"></a>故障转移的过程</h3><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="ACTIVITY" height="858px" preserveAspectRatio="none" style="width:458px;height:858px;background:#FFFFFF;" version="1.1" viewBox="0 0 458 858" width="458px" zoomAndPan="magnify"><defs/><g><ellipse cx="296.0483" cy="20" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="169.4614" x="211.3176" y="50"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="149.4614" x="221.3176" y="71.1387">Sentinel &#23450;&#26399; PING &#20027;&#33410;&#28857;</text><polygon fill="#F1F1F1" points="260.1293,103.9688,331.9672,103.9688,343.9672,115.9688,331.9672,127.9688,260.1293,127.9688,248.1293,115.9688,260.1293,103.9688" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="71.8379" x="260.1293" y="119.7769">&#20027;&#33410;&#28857;&#26080;&#21709;&#24212;?</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="10.9999" x="237.1294" y="113.3745">&#26159;</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="10.9999" x="343.9672" y="113.3745">&#21542;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="160.9596" x="115.6389" y="137.9688"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="140.9596" x="125.6389" y="159.1074">&#26631;&#35760;&#20026;&#20027;&#35266;&#19979;&#32447; S_DOWN</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="120.7816" x="135.7279" y="191.9375"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="100.7816" x="145.7279" y="213.0762">&#36890;&#30693;&#20854;&#20182; Sentinel</text><polygon fill="#F1F1F1" points="134.26,245.9063,257.9774,245.9063,269.9774,257.9063,257.9774,269.9063,134.26,269.9063,122.26,257.9063,134.26,245.9063" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="123.7173" x="134.26" y="261.7144">&#36229;&#36807;&#21322;&#25968; Sentinel &#21516;&#24847;?</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="10.9999" x="111.2601" y="255.312">&#26159;</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="10.9999" x="269.9774" y="255.312">&#21542;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="162.7878" x="30.8662" y="279.9063"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="142.7878" x="40.8662" y="301.0449">&#26631;&#35760;&#20026;&#23458;&#35266;&#19979;&#32447; O_DOWN</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="132.7817" x="45.8692" y="333.875"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="112.7817" x="55.8692" y="355.0137">&#36873;&#20030;&#39046;&#23548;&#32773; Sentinel</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="188.0942" x="18.2129" y="387.8438"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="168.0942" x="28.2129" y="408.9824">&#39046;&#23548;&#32773; Sentinel &#21457;&#36215; Failover</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104.0006" x="60.2597" y="441.8125"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84.0006" x="70.2597" y="462.9512">&#25361;&#36873;&#19968;&#20010;&#20174;&#33410;&#28857;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="202.5201" x="11" y="495.7813"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="182.5201" x="21" y="516.9199">&#21521;&#20174;&#33410;&#28857;&#21457;&#36865; SLAVEOF NO ONE</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="92.0005" x="66.2598" y="549.75"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="72.0005" x="76.2598" y="570.8887">&#26032;&#20027;&#33410;&#28857;&#19978;&#32447;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="152.001" x="36.2595" y="603.7188"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="132.001" x="46.2595" y="624.8574">&#36890;&#30693;&#20854;&#20182;&#20174;&#33410;&#28857;&#36319;&#38543;&#26032;&#20027;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="120.7816" x="51.8692" y="657.6875"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="100.7816" x="61.8692" y="678.8262">Sentinel &#26356;&#26032;&#37197;&#32622;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="92.0005" x="66.2598" y="711.6563"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="72.0005" x="76.2598" y="732.7949">&#25925;&#38556;&#36716;&#31227;&#23436;&#25104;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="68.0004" x="245.9772" y="279.9063"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="48.0004" x="255.9772" y="301.0449">&#36820;&#22238;&#30417;&#25511;</text><polygon fill="#F1F1F1" points="196.1187,751.625,208.1187,763.625,196.1187,775.625,184.1187,763.625,196.1187,751.625" style="stroke:#181818;stroke-width:0.5;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="104.0006" x="343.9775" y="137.9688"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="84.0006" x="353.9775" y="159.1074">&#32487;&#32493;&#30417;&#25511;&#20027;&#33410;&#28857;</text><polygon fill="#F1F1F1" points="296.0483,781.625,308.0483,793.625,296.0483,805.625,284.0483,793.625,296.0483,781.625" style="stroke:#181818;stroke-width:0.5;"/><ellipse cx="296.0483" cy="836.625" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1;"/><ellipse cx="296.0483" cy="836.625" fill="#222222" rx="6" ry="6" style="stroke:#222222;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="296.0483" x2="296.0483" y1="30" y2="50"/><polygon fill="#181818" points="292.0483,40,296.0483,50,300.0483,40,296.0483,44" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="196.1187" x2="196.1187" y1="171.9375" y2="191.9375"/><polygon fill="#181818" points="192.1187,181.9375,196.1187,191.9375,200.1187,181.9375,196.1187,185.9375" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="112.26" x2="112.26" y1="313.875" y2="333.875"/><polygon fill="#181818" points="108.26,323.875,112.26,333.875,116.26,323.875,112.26,327.875" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="112.26" x2="112.26" y1="367.8438" y2="387.8438"/><polygon fill="#181818" points="108.26,377.8438,112.26,387.8438,116.26,377.8438,112.26,381.8438" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="112.26" x2="112.26" y1="421.8125" y2="441.8125"/><polygon fill="#181818" points="108.26,431.8125,112.26,441.8125,116.26,431.8125,112.26,435.8125" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="112.26" x2="112.26" y1="475.7813" y2="495.7813"/><polygon fill="#181818" points="108.26,485.7813,112.26,495.7813,116.26,485.7813,112.26,489.7813" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="112.26" x2="112.26" y1="529.75" y2="549.75"/><polygon fill="#181818" points="108.26,539.75,112.26,549.75,116.26,539.75,112.26,543.75" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="112.26" x2="112.26" y1="583.7188" y2="603.7188"/><polygon fill="#181818" points="108.26,593.7188,112.26,603.7188,116.26,593.7188,112.26,597.7188" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="112.26" x2="112.26" y1="637.6875" y2="657.6875"/><polygon fill="#181818" points="108.26,647.6875,112.26,657.6875,116.26,647.6875,112.26,651.6875" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="112.26" x2="112.26" y1="691.6563" y2="711.6563"/><polygon fill="#181818" points="108.26,701.6563,112.26,711.6563,116.26,701.6563,112.26,705.6563" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="122.26" x2="112.26" y1="257.9063" y2="257.9063"/><line style="stroke:#181818;stroke-width:1;" x1="112.26" x2="112.26" y1="257.9063" y2="279.9063"/><polygon fill="#181818" points="108.26,269.9063,112.26,279.9063,116.26,269.9063,112.26,273.9063" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="269.9774" x2="279.9774" y1="257.9063" y2="257.9063"/><line style="stroke:#181818;stroke-width:1;" x1="279.9774" x2="279.9774" y1="257.9063" y2="279.9063"/><polygon fill="#181818" points="275.9774,269.9063,279.9774,279.9063,283.9774,269.9063,279.9774,273.9063" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="112.26" x2="112.26" y1="745.625" y2="763.625"/><line style="stroke:#181818;stroke-width:1;" x1="112.26" x2="184.1187" y1="763.625" y2="763.625"/><polygon fill="#181818" points="174.1187,759.625,184.1187,763.625,174.1187,767.625,178.1187,763.625" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="279.9774" x2="279.9774" y1="313.875" y2="763.625"/><line style="stroke:#181818;stroke-width:1;" x1="279.9774" x2="208.1187" y1="763.625" y2="763.625"/><polygon fill="#181818" points="218.1187,759.625,208.1187,763.625,218.1187,767.625,214.1187,763.625" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="196.1187" x2="196.1187" y1="225.9063" y2="245.9063"/><polygon fill="#181818" points="192.1187,235.9063,196.1187,245.9063,200.1187,235.9063,196.1187,239.9063" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="248.1293" x2="196.1187" y1="115.9688" y2="115.9688"/><line style="stroke:#181818;stroke-width:1;" x1="196.1187" x2="196.1187" y1="115.9688" y2="137.9688"/><polygon fill="#181818" points="192.1187,127.9688,196.1187,137.9688,200.1187,127.9688,196.1187,131.9688" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="343.9672" x2="395.9779" y1="115.9688" y2="115.9688"/><line style="stroke:#181818;stroke-width:1;" x1="395.9779" x2="395.9779" y1="115.9688" y2="137.9688"/><polygon fill="#181818" points="391.9779,127.9688,395.9779,137.9688,399.9779,127.9688,395.9779,131.9688" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="196.1187" x2="196.1187" y1="775.625" y2="793.625"/><line style="stroke:#181818;stroke-width:1;" x1="196.1187" x2="284.0483" y1="793.625" y2="793.625"/><polygon fill="#181818" points="274.0483,789.625,284.0483,793.625,274.0483,797.625,278.0483,793.625" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="395.9779" x2="395.9779" y1="171.9375" y2="793.625"/><line style="stroke:#181818;stroke-width:1;" x1="395.9779" x2="308.0483" y1="793.625" y2="793.625"/><polygon fill="#181818" points="318.0483,789.625,308.0483,793.625,318.0483,797.625,314.0483,793.625" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="296.0483" x2="296.0483" y1="83.9688" y2="103.9688"/><polygon fill="#181818" points="292.0483,93.9688,296.0483,103.9688,300.0483,93.9688,296.0483,97.9688" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="296.0483" x2="296.0483" y1="805.625" y2="825.625"/><polygon fill="#181818" points="292.0483,815.625,296.0483,825.625,300.0483,815.625,296.0483,819.625" style="stroke:#181818;stroke-width:1;"/><!--SRC=[PPBVIy9G7CNVzrTy7_LVq8S8qWZ21K8zXj2aWQpGqVEIbcN-s4WjfgG8DOYQFfGkb_dFt5_xBtBJJQt7Uy-vvtCut8ASoSiS5qiBaYnAGWwmPP1E5mxsKhk0R8ULYxJu5UV4B4J28tdeuVigdZIseY2V2X94oECWoW74IA_4h26o9vxNB2BxZavca3xUuOzISS_WAWRjFcDrX9mM151FyG1ifB9P2LVBf3c4LIEjGgxgVr7hC6prLp0-XFcuMsJ_kFrhFFXcYhf1zEH_0k2wpZx7aCo8kRCB8RyqaehkHod8VaLEBLZ5rx2cXrVprwvo2UdzxSC4duGK3tmg4MIqXk62o2xFkuObLvk4IMpSTOtwuitI5tOaxO-vuAfLEhM2yARg6XqsVQEcWwqAkT4yGSWL18XWxMMv69irSFk9jdLICtrTEX6pt8OhHXsJEkyBpze7M5WByjdvBm00]--></g></svg><p>核心点：</p><ul><li>哨兵选Leader，Raft算法<ul><li>多个Sentinel发起选举</li><li>每个Sentinel只能将票投给一个候选者</li><li>谁先拿到超过半数 Sentinel 的选票，就当选为主导故障转移的领导者（leader）</li><li>该领导者 Sentinel 执行节点的“选主”逻辑，挑选一个从节点并将其晋升为主节点</li></ul></li><li>哨兵Leader选主的原则，优先级：<ul><li>优先选择响应良好的从节点<ul><li>发送<code>INFO</code> 命令</li></ul></li><li>优选选择复制进度最接近原主节点的从节点<ul><li>比较从节点<ul><li><code>offset</code>：复制偏移量</li><li><code>master_link_down_time</code>:和主节点断开多久</li></ul></li></ul></li><li>优先选择<code>slave-priority</code>值最小的从节点<ul><li>配置 <code>replica-priority &lt;priority&gt;</code><ul><li>默认值 100</li><li>0 永远不选为主节点</li><li>值越小，优先级越高</li></ul></li></ul></li><li>用随机算法打破平局</li></ul></li></ul><h2 id="Proxy-模式"><a href="#Proxy-模式" class="headerlink" title="Proxy 模式"></a>Proxy 模式</h2><p>参考 Twitter 的 Twemproxy，是redis集群的中间层，简化客户端和redis之间的交互，是redis cluster未应用时，实现负载均衡，分片，连接池功能的替代品</p><h2 id="集群cluster模式"><a href="#集群cluster模式" class="headerlink" title="集群cluster模式"></a>集群cluster模式</h2><p>服务器sharding技术，去中心化的结构（网状结构）</p><p>通过 哈希槽（hash slots）实现数据分片，通过Gossip协议实现节点感知，并在主从结构基础上实现故障转移和高可用。</p><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><ul><li>可接受的写入安全<ul><li>系统尝试（best-effort方式，尽量）保留所有连接到master节点的client发起的写操作</li><li>存在一个小的时间窗口，时间窗内的已确认写操作可能丢失(即，在发生failover之前的小段时间窗内的写操作可能在failover中丢失)</li></ul></li><li>可用性，以下场景总是可用<ul><li>大部分maser节点可用，且对于少部分不可用的master，每个master至少有一个当前可用的slave</li><li>使用 replicas migration 技术，当前没有slave的master会从当前拥有多个slave的master接收到一个新的slave来确保可用型</li></ul></li></ul><h3 id="主要组成"><a href="#主要组成" class="headerlink" title="主要组成"></a>主要组成</h3><ul><li>hash slots：哈希槽</li><li><code>keys hash tags</code>： 分配到同一个hash slot 中； 如果 <code>&#123;hash_key&#125;</code>中存在字符，key的hash值按照hash_key进行计算；</li><li>cluster nodes 属性：节点在 cluster 中存在一个唯一的名字 <code>info cluster</code></li><li>cluster 总线： <code>cluster bus</code> 集群总线通信<ul><li>每个redis cluster节点 有一个额外的TCP断开用来接收其他节点的连接，这个端口与用来接收client命令的普通TCP端口有一个固定的offset。该端口等于普通命令端口加上10000.例如，一个Redis在端口6379客户端连接，那么它的集群总线端口16379也会被打开</li><li>节点间的通信只使用集群总线，同时使用集群总线协议：有不同的类型和大小的帧组成的二进制协议；</li></ul></li><li>集群拓扑：<ul><li>全网拓扑，每个节点都和其他节点之间保持TCP连接； </li><li>在一个拥有N个节点的集群中，每个节点由N-1个TCP传出连接，和N-1个TCP传入连接。</li><li>ping-pong保活，节点使用gossip协议和配置更新机制来避免在正常情况下节点之间交换过多的消息，因此集群内交换的消息数目(相对节点数目)不是指数级的</li></ul></li><li>节点握手：<ul><li>节点总是接受集群总线端口的连接，并且总是会回复ping请求，即使ping来自一个不可信节点。</li><li>认证节点的方式<ul><li><code>meet</code> 消息，强制接受者接受一个节点作为集群的一部分，节点只有在接受到系统管理员的如下命令后，才会向其他节点发送<code>meet</code>消息：<code>cluster meet ip port</code></li><li>如果一个被信任的节点 gossip了某个节点，那么接受到gossip消息的节点也会将那个节点标记为集群的一部分，gossip通知其他节点；</li></ul></li><li>在一个节点上meet就能够在集群中加入一个新的节点</li></ul></li></ul><h3 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h3><p>分布式系统中用于<strong>信息传播，状态同步和节点发现</strong>的通信机制，具有去中心化，可扩展，最终一致等特点</p><p>在 Redis Cluster 中，Gossip 是 集群总线通信的基础协议，用于让各个节点之间周期性地交换彼此所知道的集群信息。</p><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li>去中心化<ul><li>没有中心节点，所有节点平等</li></ul></li><li>定期交换<ul><li>每个节点定期向其他节点发送状态</li></ul></li><li>随机传播<ul><li>每次只和一个&#x2F;少数节点通信</li></ul></li><li>最终一致性<ul><li>信息可能传播较慢，最终所有节点将同步状态</li></ul></li><li>容错性<ul><li>即使网络抖动&#x2F;部分节点故障 也能够继续传播信息</li></ul></li></ul><h4 id="Gossip流程"><a href="#Gossip流程" class="headerlink" title="Gossip流程"></a>Gossip流程</h4><ol><li>周期性的触发<ul><li>每个Redis节点每100ms左右从集群中随机挑选若干节点进行 Gossip 通信</li></ul></li><li>发送 PING 消息<ul><li>Gossip 信息嵌套在 Cluster Bus 的 PING 包中</li><li>包含：<ul><li>自己的状态</li><li>对其他若干节点的转述信息</li></ul></li></ul></li><li>接受并更新状态<ul><li>收到 PING 或 PONG 包后，接收方根据其中的 Gossip 信息更新自己对整个集群的状态视图。</li></ul></li><li>传播失败消息<ul><li>如果某个节点连续一段时间未回应心跳，会被标记为 PFAIL</li><li>一旦半数以上节点 Gossip 传播这个状态并达成一致，就会标记为 FAIL，并触发故障转移</li></ul></li></ol><h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><ul><li>Meet消息<ul><li>通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换</li></ul></li><li>PING消息<ul><li>集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息</li></ul></li><li>PONG消息<ul><li>当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新</li></ul></li><li>FAIL消息<ul><li>当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态</li></ul></li></ul><h4 id="故障恢复-failover"><a href="#故障恢复-failover" class="headerlink" title="故障恢复 failover"></a>故障恢复 failover</h4><p>slave发现master变为FAIL状态，尝试进行 failover，成为新的master；</p><p>由于挂掉的master可能会有多个slave。Failover的过程需要经过类Raft协议的过程在整个集群内达到一致， 其过程如下：</p><ol><li>slave发现自己的master变为FAIL</li><li>将自己记录的集群currentEpoch（逻辑版本号）递增，并广播<code>FAILOVER_AUTH_REQUEST</code>给所有的master节点</li><li>其他非故障的master节点收到该信息，判断请求者的合法性，并发送 <code>FAILOVER_AUTH_ACK</code>,对每个epoch只发送一次ack</li><li>尝试 failover 的slave收集FAILOVER_AUTH_ACK</li><li>超过活跃master节点 半数后变为新的master</li><li>新的 master 会通过带角色信息的 PONG 消息，通知其他节点其角色变化，并通过 CLUSTER SETSLOT 宣布对 slot 的主控权</li></ol><p>通过epoch（版本号），保证一轮中的投票唯一</p><h4 id="扩缩容"><a href="#扩缩容" class="headerlink" title="扩缩容"></a>扩缩容</h4><p>扩容为例，缩容类似：</p><ol><li>将新节点加入集群，可以通过在集群中任何一个客户端执行cluster meet 新节点ip:端口，或者通过redis-trib add node添加，新添加的节点默认在集群中都是主节点；</li><li>迁移数据，确定哪些槽需要被迁移到目标节点，然后获取槽中的key，将槽中的key全部迁移，</li><li>向集群中所有主节点广播槽（数据）迁移到目标节点</li></ol><p>命令：</p><ul><li>targetNodeId 新节点：<code>cluster setslot &#123;slot&#125; importing &#123;sourceNodeId&#125;</code></li><li>sourceNodeId 源数据节点：<code>cluster setslot &#123;slot&#125; migrate &#123;targetNodeId&#125;</code></li><li>广播槽已经迁移完成 <code>cluster setslot &#123;slot&#125; node &#123;targetNodeId&#125;</code></li></ul><p>NOTE：<br>使用 <code>redis-cli --cluster reshard</code>命令，会自动完成扩缩容的过程</p><h5 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h5><p>当访问的key值，不在当前节点时，引导到正确的节点</p><p>两种重定向机制：</p><ul><li><code>MOVED</code>:客户端访问的slot已经迁走，通知客户端更新 slot-&gt;node映射</li><li><code>ASK</code>：slot正在迁移中，下次请求携带 <code>ASKING</code> 命令，不修改映射（因为迁移未完成）</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>槽的数量问题：16384(2^14)（16k）：crc16最多（2^16-1）但是会导致心跳包的8k；过大；使用希望将心跳包的大小控制在2k；使用bitmap压缩后16384个槽使用2k空间；</li><li>redis cluster发布订阅问题（为什么不使用）<ul><li>在集群模式下，所有的publish命令都会向所有节点（包括从节点）进行广播，造成每条publish数据都会在集群内所有节点传播一次，加重了带宽负担，</li><li>对于在有大量节点的集群中频繁使用pub，会严重消耗带宽，不建议使用</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>cluster</tag>
      
      <tag>sentinel</tag>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 持久化机制</title>
    <link href="/2025/04/24/redis/persistence/"/>
    <url>/2025/04/24/redis/persistence/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a>Redis 持久化机制</h1><p>持久化的意义：为了保证异常情况下的数据安全</p><p>redis的持久化机制主要包含RDB，AOF，混合三种模式；</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>COW（Copy On Write） 写时拷贝技术（将复制操作推迟到第一次修改数据）；</p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想:"></a>核心思想:</h3><p>如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变</p><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>RDB持久化指在指定的时间间隔内将内存中的数据快照写入磁盘；<br>RDB是默认的持久化方式，默认文件名为 dump.rdb;</p><h3 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h3><p><code>save</code>（阻塞） 和 <code>bgsave</code></p><p>配置触发：<code>save &lt;seconds&gt; &lt;change-key-number&gt;</code> 在指定seconds内，若key的变更数达到了<code>change-key-number</code>，则触发保存</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：<ul><li>RDB文件紧凑（二进制），全量备份，适合用于备份和容灾</li><li>生成RDB文件支持异步处理，主进程不需要IO操作</li><li>RDB在恢复大数据集时的速度比AOF更快</li></ul></li><li>缺点<ul><li>RDB是一次全量备份的，存储二进制序列化数据，且在快照持久化期间修改的数据不会被保存，可能丢失数据（宕机情况）。</li><li>RDB 只会在触发快照时保存数据，快照间隔期间的数据变更若未持久化，宕机时会丢失；</li></ul></li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>适用于对数据安全性要求不是极致苛刻、允许短时间数据丢失的场景，如缓存型业务、周期性全量备份、灾备容灾等。</li><li>适合数据量较大、恢复速度要求高的场合。</li><li>适合主从复制、定期快照归档等对性能有较高要求的业务。</li></ul><h3 id="bgsave的执行流程"><a href="#bgsave的执行流程" class="headerlink" title="bgsave的执行流程"></a>bgsave的执行流程</h3><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="ACTIVITY" height="1159px" preserveAspectRatio="none" style="width:1080px;height:1159px;background:#FFFFFF;" version="1.1" viewBox="0 0 1080 1159" width="1080px" zoomAndPan="magnify"><title>Redis BGSAVE &#20027;&#65288;&#29238;&#65289;&#36827;&#31243; vs &#23376;&#36827;&#31243;&#27969;&#31243;&#22270;</title><defs/><g><g class="title" data-source-line="1"><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="311.8616" x="382.6712" y="32.9951">Redis BGSAVE &#20027;&#65288;&#29238;&#65289;&#36827;&#31243; vs &#23376;&#36827;&#31243;&#27969;&#31243;&#22270;</text></g><rect fill="none" height="20.9531" style="stroke:none;stroke-width:1;" width="1047.204" x="15" y="50.042"/><ellipse cx="267.986" cy="85.9951" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="147.2188" x="194.3766" y="115.9951"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="127.2188" x="204.3766" y="137.1338">BGSAVE [SCHEDULE]</text><polygon fill="#F1F1F1" points="176.5409,169.9639,359.4311,169.9639,371.4311,181.9639,359.4311,193.9639,176.5409,193.9639,164.5409,181.9639,176.5409,169.9639" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="182.8902" x="176.5409" y="185.772">&#26159;&#21542;&#23384;&#22312;&#23376;&#36827;&#31243;&#22312;&#25191;&#34892;BGSAVE&#25805;&#20316;?</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="10.9999" x="153.5409" y="179.3696">&#26159;</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="10.9999" x="371.4311" y="179.3696">&#21542;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="92.0005" x="21" y="203.9639"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="72.0005" x="31" y="225.1025">&#36820;&#22238;&#38169;&#35823;&#20449;&#24687;</text><ellipse cx="67.0003" cy="283.9326" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1;"/><ellipse cx="67.0003" cy="283.9326" fill="#222222" rx="6" ry="6" style="stroke:#222222;stroke-width:1;"/><polygon fill="#F1F1F1" points="402.262,203.9639,615.6813,203.9639,627.6813,215.9639,615.6813,227.9639,402.262,227.9639,390.262,215.9639,402.262,203.9639" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="213.4193" x="402.262" y="219.772">&#26159;&#21542;&#23384;&#22312;RDB/AOF/&#27169;&#22359;&#30340;&#23376;&#36827;&#31243;&#27491;&#22312;&#25191;&#34892;?</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="10.9999" x="379.2621" y="213.3696">&#26159;</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="10.9999" x="627.6813" y="213.3696">&#21542;</text><polygon fill="#F1F1F1" points="307.6628,237.9639,438.9856,237.9639,450.9856,249.9639,438.9856,261.9639,307.6628,261.9639,295.6628,249.9639,307.6628,237.9639" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="131.3228" x="307.6628" y="253.772">&#26159;&#21542;&#20351;&#29992;SCHEDULE&#21442;&#25968;?</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="10.9999" x="284.6629" y="247.3696">&#26159;</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="10.9999" x="450.9856" y="247.3696">&#21542;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="68.0004" x="220.4194" y="271.9639"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="48.0004" x="230.4194" y="293.1025">&#25171;&#19978;&#26631;&#35782;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="189.1494" x="159.8449" y="340.9326"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="169.1494" x="169.8449" y="362.0713">&#20043;&#21518;&#22312;&#26102;&#38388;&#20107;&#20214;&#20013;&#35302;&#21457;BGSAVE</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="105.811" x="201.5141" y="409.9014"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="85.811" x="211.5141" y="431.04">&#35302;&#21457;RDB&#21518;&#21488;&#20889;</text><polygon fill="#F1F1F1" points="191.0008,463.8701,317.8384,463.8701,329.8384,475.8701,317.8384,487.8701,191.0008,487.8701,179.0008,475.8701,191.0008,463.8701" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="126.8375" x="191.0008" y="479.6782">&#26159;&#21542;&#23384;&#22312;&#23376;&#36827;&#31243;&#27491;&#22312;&#25191;&#34892;?</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="10.9999" x="168.0009" y="473.2759">&#26159;</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="10.9999" x="329.8384" y="473.2759">&#21542;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="92.0005" x="123.0005" y="497.8701"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="72.0005" x="133.0005" y="519.0088">&#36820;&#22238;&#38169;&#35823;&#20449;&#24687;</text><ellipse cx="169.0008" cy="562.8389" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1;"/><ellipse cx="169.0008" cy="562.8389" fill="#222222" rx="6" ry="6" style="stroke:#222222;stroke-width:1;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="79.4495" x="300.1136" y="497.8701"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="59.4495" x="310.1136" y="519.0088">fork&#23376;&#36827;&#31243;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="152.7802" x="263.4483" y="551.8389"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="132.7802" x="273.4483" y="572.9775">&#35760;&#24405;&#23376;&#36827;&#31243;ID&#31561;&#30456;&#20851;&#20449;&#24687;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="128.0008" x="275.838" y="605.8076"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="108.0008" x="285.838" y="626.9463">&#27491;&#24120;&#22788;&#29702;&#23458;&#25143;&#31471;&#35831;&#27714;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="92.0005" x="446.2285" y="271.9639"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="72.0005" x="456.2285" y="293.1025">&#36820;&#22238;&#38169;&#35823;&#20449;&#24687;</text><ellipse cx="492.2287" cy="351.9326" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1;"/><ellipse cx="492.2287" cy="351.9326" fill="#222222" rx="6" ry="6" style="stroke:#222222;stroke-width:1;"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="79.4495" x="604.8944" y="237.9639"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="59.4495" x="614.8944" y="259.1025">fork&#23376;&#36827;&#31243;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="152.7802" x="568.229" y="306.9326"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="132.7802" x="578.229" y="328.0713">&#35760;&#24405;&#23376;&#36827;&#31243;ID&#31561;&#30456;&#20851;&#20449;&#24687;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="128.0008" x="580.6187" y="375.9014"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="108.0008" x="590.6187" y="397.04">&#27491;&#24120;&#22788;&#29702;&#23458;&#25143;&#31471;&#35831;&#27714;</text><polygon fill="#F1F1F1" points="508.9716,649.7764,520.9716,661.7764,508.9716,673.7764,496.9716,661.7764,508.9716,649.7764" style="stroke:#181818;stroke-width:0.5;"/><line style="stroke:#000000;stroke-width:1.5;" x1="15" x2="15" y1="50.042" y2="1147.5264"/><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="68.2578" x="859.5473" y="693.7764"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="48.2578" x="869.5473" y="714.915">rdbsave</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="92.0005" x="847.6759" y="747.7451"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="72.0005" x="857.6759" y="768.8838">&#21019;&#24314;&#20020;&#26102;&#25991;&#20214;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="325.334" x="731.0092" y="801.7139"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="305.334" x="741.0092" y="822.8525">&#20889;&#20837; Redis &#39764;&#27861;&#20540;&#12289;&#29256;&#26412;&#21495;&#12289;&#22797;&#21046;ID&#12289;&#22797;&#21046;&#20559;&#31227;&#37327;&#31561;&#20449;&#24687;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="284.002" x="751.6752" y="855.6826"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="264.002" x="761.6752" y="876.8213">&#36941;&#21382;&#25968;&#25454;&#24211;&#25152;&#26377;&#38190;&#20540;&#21450;&#36807;&#26399;&#26102;&#38388;&#24182;&#20445;&#23384;&#21040;&#20020;&#26102;&#25991;&#20214;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="322.1574" x="732.5975" y="909.6514"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="302.1574" x="742.5975" y="930.79">&#20889;&#20837; Lua &#33050;&#26412;&#12289;RDB_OPCODE_EOF &#32467;&#26463;&#26631;&#24535;&#12289;&#26657;&#39564;&#21644;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="128.0008" x="829.6758" y="963.6201"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="108.0008" x="839.6758" y="984.7588">&#23558;&#20020;&#26102;&#25991;&#20214;&#21047;&#20837;&#30913;&#30424;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="185.4405" x="800.956" y="1017.5889"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="165.4405" x="810.956" y="1038.7275">&#29992;&#20020;&#26102;&#25991;&#20214;&#26367;&#25442;&#26087;&#30340; RDB &#25991;&#20214;</text><rect fill="#F1F1F1" height="33.9688" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="155.2468" x="816.0528" y="1071.5576"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="135.2468" x="826.0528" y="1092.6963">&#35760;&#24405; SAVE &#30340;&#26102;&#38388;&#21644;&#29366;&#24577;</text><ellipse cx="893.6762" cy="1136.5264" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1;"/><ellipse cx="893.6762" cy="1136.5264" fill="#222222" rx="6" ry="6" style="stroke:#222222;stroke-width:1;"/><line style="stroke:#000000;stroke-width:1.5;" x1="725.0092" x2="725.0092" y1="50.042" y2="1147.5264"/><line style="stroke:#000000;stroke-width:1.5;" x1="1060.3432" x2="1060.3432" y1="50.042" y2="1147.5264"/><line style="stroke:#181818;stroke-width:1;" x1="267.986" x2="267.986" y1="95.9951" y2="115.9951"/><polygon fill="#181818" points="263.986,105.9951,267.986,115.9951,271.986,105.9951,267.986,109.9951" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="67.0003" x2="67.0003" y1="237.9326" y2="272.9326"/><polygon fill="#181818" points="63.0003,262.9326,67.0003,272.9326,71.0003,262.9326,67.0003,266.9326" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="254.4196" x2="254.4196" y1="305.9326" y2="340.9326"/><polygon fill="#181818" points="250.4196,330.9326,254.4196,340.9326,258.4196,330.9326,254.4196,334.9326" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="254.4196" x2="254.4196" y1="374.9014" y2="409.9014"/><polygon fill="#181818" points="250.4196,399.9014,254.4196,409.9014,258.4196,399.9014,254.4196,403.9014" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="169.0008" x2="169.0008" y1="531.8389" y2="551.8389"/><polygon fill="#181818" points="165.0008,541.8389,169.0008,551.8389,173.0008,541.8389,169.0008,545.8389" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="339.8384" x2="339.8384" y1="531.8389" y2="551.8389"/><polygon fill="#181818" points="335.8384,541.8389,339.8384,551.8389,343.8384,541.8389,339.8384,545.8389" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="339.8384" x2="339.8384" y1="585.8076" y2="605.8076"/><polygon fill="#181818" points="335.8384,595.8076,339.8384,605.8076,343.8384,595.8076,339.8384,599.8076" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="179.0008" x2="169.0008" y1="475.8701" y2="475.8701"/><line style="stroke:#181818;stroke-width:1;" x1="169.0008" x2="169.0008" y1="475.8701" y2="497.8701"/><polygon fill="#181818" points="165.0008,487.8701,169.0008,497.8701,173.0008,487.8701,169.0008,491.8701" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="329.8384" x2="339.8384" y1="475.8701" y2="475.8701"/><line style="stroke:#181818;stroke-width:1;" x1="339.8384" x2="339.8384" y1="475.8701" y2="497.8701"/><polygon fill="#181818" points="335.8384,487.8701,339.8384,497.8701,343.8384,487.8701,339.8384,491.8701" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="339.8384" x2="339.8384" y1="639.7764" y2="661.7764"/><line style="stroke:#181818;stroke-width:1;" x1="339.8384" x2="496.9716" y1="661.7764" y2="661.7764"/><polygon fill="#181818" points="486.9716,657.7764,496.9716,661.7764,486.9716,665.7764,490.9716,661.7764" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="254.4196" x2="254.4196" y1="443.8701" y2="463.8701"/><polygon fill="#181818" points="250.4196,453.8701,254.4196,463.8701,258.4196,453.8701,254.4196,457.8701" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="492.2287" x2="492.2287" y1="305.9326" y2="340.9326"/><polygon fill="#181818" points="488.2287,330.9326,492.2287,340.9326,496.2287,330.9326,492.2287,334.9326" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="295.6628" x2="254.4196" y1="249.9639" y2="249.9639"/><line style="stroke:#181818;stroke-width:1;" x1="254.4196" x2="254.4196" y1="249.9639" y2="271.9639"/><polygon fill="#181818" points="250.4196,261.9639,254.4196,271.9639,258.4196,261.9639,254.4196,265.9639" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="450.9856" x2="492.2287" y1="249.9639" y2="249.9639"/><line style="stroke:#181818;stroke-width:1;" x1="492.2287" x2="492.2287" y1="249.9639" y2="271.9639"/><polygon fill="#181818" points="488.2287,261.9639,492.2287,271.9639,496.2287,261.9639,492.2287,265.9639" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="644.6191" x2="644.6191" y1="271.9326" y2="306.9326"/><polygon fill="#181818" points="640.6191,296.9326,644.6191,306.9326,648.6191,296.9326,644.6191,300.9326" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="644.6191" x2="644.6191" y1="340.9014" y2="375.9014"/><polygon fill="#181818" points="640.6191,365.9014,644.6191,375.9014,648.6191,365.9014,644.6191,369.9014" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="390.262" x2="373.3242" y1="215.9639" y2="215.9639"/><line style="stroke:#181818;stroke-width:1;" x1="373.3242" x2="373.3242" y1="215.9639" y2="237.9639"/><polygon fill="#181818" points="369.3242,227.9639,373.3242,237.9639,377.3242,227.9639,373.3242,231.9639" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="627.6813" x2="644.6191" y1="215.9639" y2="215.9639"/><line style="stroke:#181818;stroke-width:1;" x1="644.6191" x2="644.6191" y1="215.9639" y2="237.9639"/><polygon fill="#181818" points="640.6191,227.9639,644.6191,237.9639,648.6191,227.9639,644.6191,231.9639" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="644.6191" x2="644.6191" y1="409.8701" y2="661.7764"/><line style="stroke:#181818;stroke-width:1;" x1="644.6191" x2="520.9716" y1="661.7764" y2="661.7764"/><polygon fill="#181818" points="530.9716,657.7764,520.9716,661.7764,530.9716,665.7764,526.9716,661.7764" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="164.5409" x2="67.0003" y1="181.9639" y2="181.9639"/><line style="stroke:#181818;stroke-width:1;" x1="67.0003" x2="67.0003" y1="181.9639" y2="203.9639"/><polygon fill="#181818" points="63.0003,193.9639,67.0003,203.9639,71.0003,193.9639,67.0003,197.9639" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="371.4311" x2="508.9716" y1="181.9639" y2="181.9639"/><line style="stroke:#181818;stroke-width:1;" x1="508.9716" x2="508.9716" y1="181.9639" y2="203.9639"/><polygon fill="#181818" points="504.9716,193.9639,508.9716,203.9639,512.9716,193.9639,508.9716,197.9639" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="508.9716" x2="508.9716" y1="673.7764" y2="678.7764"/><line style="stroke:#181818;stroke-width:1;" x1="508.9716" x2="893.6762" y1="678.7764" y2="678.7764"/><line style="stroke:#181818;stroke-width:1;" x1="893.6762" x2="893.6762" y1="678.7764" y2="693.7764"/><polygon fill="#181818" points="889.6762,683.7764,893.6762,693.7764,897.6762,683.7764,893.6762,687.7764" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="267.986" x2="267.986" y1="149.9639" y2="169.9639"/><polygon fill="#181818" points="263.986,159.9639,267.986,169.9639,271.986,159.9639,267.986,163.9639" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="893.6762" x2="893.6762" y1="727.7451" y2="747.7451"/><polygon fill="#181818" points="889.6762,737.7451,893.6762,747.7451,897.6762,737.7451,893.6762,741.7451" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="893.6762" x2="893.6762" y1="781.7139" y2="801.7139"/><polygon fill="#181818" points="889.6762,791.7139,893.6762,801.7139,897.6762,791.7139,893.6762,795.7139" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="893.6762" x2="893.6762" y1="835.6826" y2="855.6826"/><polygon fill="#181818" points="889.6762,845.6826,893.6762,855.6826,897.6762,845.6826,893.6762,849.6826" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="893.6762" x2="893.6762" y1="889.6514" y2="909.6514"/><polygon fill="#181818" points="889.6762,899.6514,893.6762,909.6514,897.6762,899.6514,893.6762,903.6514" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="893.6762" x2="893.6762" y1="943.6201" y2="963.6201"/><polygon fill="#181818" points="889.6762,953.6201,893.6762,963.6201,897.6762,953.6201,893.6762,957.6201" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="893.6762" x2="893.6762" y1="997.5889" y2="1017.5889"/><polygon fill="#181818" points="889.6762,1007.5889,893.6762,1017.5889,897.6762,1007.5889,893.6762,1011.5889" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="893.6762" x2="893.6762" y1="1051.5576" y2="1071.5576"/><polygon fill="#181818" points="889.6762,1061.5576,893.6762,1071.5576,897.6762,1061.5576,893.6762,1065.5576" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="893.6762" x2="893.6762" y1="1105.5264" y2="1125.5264"/><polygon fill="#181818" points="889.6762,1115.5264,893.6762,1125.5264,897.6762,1115.5264,893.6762,1119.5264" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="107.9994" x="316.0049" y="66.75">&#20027;&#65288;&#29238;&#65289;&#36827;&#31243;</text><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="53.9997" x="865.6764" y="66.75">&#23376;&#36827;&#31243;</text><!--SRC=[ZLHTJzfG6BxlhpYNUkKzN2mgk9cOi6YscsKnB9ICpEW2p2ikg45e-R1CO825AUg4R8EowA3oiVwOzJsdlV8lx9H2nv2vzQ8vVJ-Uvta_JiE1y0wBDbbV88HM7cyjFtSZJUdV3NZ2T-u6WgvAf952-o44pQprWRzpz0tI3oPoFpB2XCBUO9XnZB5URAq-SRkURRXVEfc07otWaWpPAsYMeDAm4UaP2tMzbhQIS2wZ3IkF5b7uDRixIbba47BeQXwaZqQ-hCkofjOm9pkfEHJUUykmEo4MBL1WCt2MPjErihJiMLl2ZHfKY-GazhkIveLDFKitZQCDLP9lJ2e1yG0NslVZgKGiv3GbYSyIkXntJepQRGgoHoPHiMCKRxHUIkjtDAMfrwz0V6-LR0TRHYhPJ17R42zFN7_jtiDLMAXpMsSzemPQnp_QE4xrxmNVs5JEASXM6uO5sxFk8as1I0eSNiyIE4o1YWANCPADG-iSyrtoHTRbBlvsC8bYTtq1FpDNmmFYRUcJz9daUUB_K_Y_H5kCrfk9s6WHnX7qlGfvzradum1UWdvFKsxeuF6719swQOoNuV3J-C8PpJo-Ba1qy3FA4O77bQyWTkaPBZF0TzPTzX4uaTJxHaAaOYSo7GQNWQCutKMSQK4lXuKehWX6laNnG4pgQW9NJgsTWzkEfbRDlU7Ry_LilFCYFNP25L1EkdxRdgUh7fTxs-rPGwIVmzLJkjMW5gaNdzMCpsauJflPxVWq7l1T2aOkE2ALg9TUccalbbISESV5Ehs3Y78WMuGr4pJwOr3dMFHncYGxECev6NFGlm00]--></g></svg><h2 id="AOF持久化机制"><a href="#AOF持久化机制" class="headerlink" title="AOF持久化机制"></a>AOF持久化机制</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>AOF：写，删除，修改命令追加写入</p><p>随着时间推移，AOF持久化文件会不断变大；为了解决此问题，Redis 提供了 <code>bgrewriteaof</code> 命令，作用是fork一个新进程将内存中的数据以命令的方式保存到临时文件中，完成对于<code>AOF文件重写</code></p><h3 id="配置开启和触发"><a href="#配置开启和触发" class="headerlink" title="配置开启和触发"></a>配置开启和触发</h3><p>开启：<code>appendonly yes</code></p><p>aof文件名：AOF 文件名通过 <code>appendfilename</code> 配置，默认 <code>appendonly.aof</code></p><p>aof刷盘策略：<code>appendfsync &lt;strategy&gt;</code></p><ul><li><code>always</code>:每次写操作都进行 fsync，最安全但是性能最差</li><li><code>everysec</code>: 每秒进行一次fsync（推荐，兼顾性能和安全）</li><li><code>no</code>:操作系统决定何时 fsync，性能最好但可能丢数据</li></ul><p>aof重写：自动瘦身，通过 <code>bgrewriteaof</code> 命令或者配置自动触发实现</p><ul><li><code>auto-aof-rewrite-percentage 100</code></li><li><code>auto-aof-rewrite-min-size 64mb</code></li></ul><p>当 AOF 文件大小是上次重写后大小的 N% 且文件超过 M 大小时触发重写<br>如果 AOF 文件大小大于 64MB 且增长了一倍，则触发重写</p><p>重写时是否压缩输出命令：是否分批写入，降低IO峰值</p><p><code>aof-rewrite-incremental-fsync yes</code></p><p>重写触发： <code>bgrewriteaof</code></p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点<ul><li>更好的保护数据不丢失，一般每秒执行一次 fsync 操作同步指令</li><li>aof文件顺序写入，性能较高，顺序写磁盘比随机写性能更优</li><li>aof文件过大，会重写，不会影响客户端读写；<ul><li><font color='red'>重写时新增的命令会被放入aof缓冲区中，保证数据不丢失；aof缓冲区满，阻塞写操作</font></li></ul></li></ul></li><li>缺点<ul><li>占用空间大</li><li>AOF文件才用先写日志在执行命令的方式，提升数据的安全性，但可能带来一定的性能损耗；<ul><li>解决：<ul><li>降低 aof 刷盘频率</li><li>开启 aof 重写缓冲区</li></ul></li></ul></li></ul></li></ul><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>适用于对数据持久性要求极高、不能容忍数据丢失的金融、电商订单等核心业务。</li><li>适合需要实时记录每一次写操作、追溯数据变更历史的场景。</li><li>适合对恢复精度要求高、但可接受一定性能损耗的业务。</li></ul><h3 id="bgrewriteaof-流程"><a href="#bgrewriteaof-流程" class="headerlink" title="bgrewriteaof 流程"></a>bgrewriteaof 流程</h3><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="SEQUENCE" height="1182px" preserveAspectRatio="none" style="width:777px;height:1182px;background:#FFFFFF;" version="1.1" viewBox="0 0 777 1182" width="777px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="1063.2031" style="stroke:#000000;stroke-width:1.5;" width="760.6035" x="10" y="95.4297"/><rect fill="none" height="975.1328" style="stroke:#000000;stroke-width:1.5;" width="740.6035" x="20" y="176.5"/><rect fill="none" height="844.9297" style="stroke:#000000;stroke-width:1.5;" width="720.6035" x="30" y="299.7031"/><rect fill="none" height="131.3359" style="stroke:#000000;stroke-width:1.5;" width="295.0002" x="377.0002" y="708.1016"/><g><title>&#20027;&#65288;&#29238;&#65289;&#36827;&#31243;</title><rect fill="#000000" fill-opacity="0.00000" height="1139.3359" width="8" x="114.9998" y="36.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="118" x2="118" y1="36.2969" y2="1175.6328"/></g><g><title>&#23376;&#36827;&#31243;</title><rect fill="#000000" fill-opacity="0.00000" height="1139.3359" width="8" x="441.0001" y="36.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="444.0002" x2="444.0002" y1="36.2969" y2="1175.6328"/></g><g class="participant participant-head" data-participant="Main"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="97.9996" x="70" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="83.9996" x="77" y="24.9951">&#20027;&#65288;&#29238;&#65289;&#36827;&#31243;</text></g><g class="participant participant-head" data-participant="Child"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="55.9998" x="417.0002" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="41.9998" x="424.0002" y="24.9951">&#23376;&#36827;&#31243;</text></g><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="67.4297" y2="67.4297"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="67.4297" y2="80.4297"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="80.4297" y2="80.4297"/><polygon fill="#181818" points="129.9998,76.4297,119.9998,80.4297,129.9998,84.4297" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="104.7173" x="125.9998" y="62.3638">BGREWRITEAOF</text></g><path d="M10,95.4297 L74.4429,95.4297 L74.4429,102.5625 L64.4429,112.5625 L10,112.5625 L10,95.4297" fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="1063.2031" style="stroke:#000000;stroke-width:1.5;" width="760.6035" x="10" y="95.4297"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="19.4429" x="25" y="108.4966">alt</text><text fill="#000000" font-family="sans-serif" font-size="11" font-weight="bold" lengthAdjust="spacing" textLength="134.4324" x="89.4429" y="107.6401">[&#23376;&#36827;&#31243;&#27491;&#22312;&#25191;&#34892;AOF&#37325;&#20889;]</text><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="133.6953" y2="133.6953"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="133.6953" y2="146.6953"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="146.6953" y2="146.6953"/><polygon fill="#181818" points="129.9998,142.6953,119.9998,146.6953,129.9998,150.6953" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78.0001" x="125.9998" y="128.6294">&#36820;&#22238;&#38169;&#35823;&#20449;&#24687;</text></g><line style="stroke:#000000;stroke-width:1;stroke-dasharray:2.0,2.0;" x1="10" x2="770.6035" y1="155.6953" y2="155.6953"/><text fill="#000000" font-family="sans-serif" font-size="11" font-weight="bold" lengthAdjust="spacing" textLength="123.4325" x="15" y="165.9058">[&#19981;&#23384;&#22312;AOF&#37325;&#20889;&#23376;&#36827;&#31243;]</text><path d="M20,176.5 L84.4429,176.5 L84.4429,183.6328 L74.4429,193.6328 L20,193.6328 L20,176.5" fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="975.1328" style="stroke:#000000;stroke-width:1.5;" width="740.6035" x="20" y="176.5"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="19.4429" x="35" y="189.5669">alt</text><text fill="#000000" font-family="sans-serif" font-size="11" font-weight="bold" lengthAdjust="spacing" textLength="146.4531" x="99.4429" y="188.7104">[&#23384;&#22312;RDB/AOF/&#27169;&#22359;&#23376;&#36827;&#31243;]</text><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="214.7656" y2="214.7656"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="214.7656" y2="227.7656"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="227.7656" y2="227.7656"/><polygon fill="#181818" points="129.9998,223.7656,119.9998,227.7656,129.9998,231.7656" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="260.7175" x="125.9998" y="209.6997">&#25171;&#19978;&#26631;&#35782;&#65292;&#20043;&#21518;&#20107;&#20214;&#20013;&#35302;&#21457;BGREWRITEAOF</text></g><line style="stroke:#000000;stroke-width:1;stroke-dasharray:2.0,2.0;" x1="20" x2="760.6035" y1="236.7656" y2="236.7656"/><text fill="#000000" font-family="sans-serif" font-size="11" font-weight="bold" lengthAdjust="spacing" textLength="76.0542" x="25" y="246.9761">[&#26080;&#20854;&#20182;&#23376;&#36827;&#31243;]</text><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="271.7031" y2="271.7031"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="271.7031" y2="284.7031"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="284.7031" y2="284.7031"/><polygon fill="#181818" points="129.9998,280.7031,119.9998,284.7031,129.9998,288.7031" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="104.6031" x="125.9998" y="266.6372">&#35302;&#21457;AOF&#21518;&#21488;&#37325;&#20889;</text></g><path d="M30,299.7031 L94.4429,299.7031 L94.4429,306.8359 L84.4429,316.8359 L30,316.8359 L30,299.7031" fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="844.9297" style="stroke:#000000;stroke-width:1.5;" width="720.6035" x="30" y="299.7031"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="19.4429" x="45" y="312.77">alt</text><text fill="#000000" font-family="sans-serif" font-size="11" font-weight="bold" lengthAdjust="spacing" textLength="87.0542" x="109.4429" y="311.9136">[&#23384;&#22312;&#23376;&#36827;&#31243;&#20914;&#31361;]</text><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="337.9688" y2="337.9688"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="337.9688" y2="350.9688"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="350.9688" y2="350.9688"/><polygon fill="#181818" points="129.9998,346.9688,119.9998,350.9688,129.9998,354.9688" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78.0001" x="125.9998" y="332.9028">&#36820;&#22238;&#38169;&#35823;&#20449;&#24687;</text></g><line style="stroke:#000000;stroke-width:1;stroke-dasharray:2.0,2.0;" x1="30" x2="750.6035" y1="359.9688" y2="359.9688"/><text fill="#000000" font-family="sans-serif" font-size="11" font-weight="bold" lengthAdjust="spacing" textLength="43.0545" x="35" y="370.1792">[&#26080;&#20914;&#31361;]</text><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="394.9063" y2="394.9063"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="394.9063" y2="407.9063"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="407.9063" y2="407.9063"/><polygon fill="#181818" points="129.9998,403.9063,119.9998,407.9063,129.9998,411.9063" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="64.4034" x="125.9998" y="389.8403">fork&#23376;&#36827;&#31243;</text></g><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="437.0391" y2="437.0391"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="437.0391" y2="450.0391"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="450.0391" y2="450.0391"/><polygon fill="#181818" points="129.9998,446.0391,119.9998,450.0391,129.9998,454.0391" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117.8444" x="125.9998" y="431.9731">&#35760;&#24405;&#23376;&#36827;&#31243;ID&#31561;&#20449;&#24687;</text></g><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="509.4375" y2="509.4375"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="509.4375" y2="522.4375"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="522.4375" y2="522.4375"/><polygon fill="#181818" points="129.9998,518.4375,119.9998,522.4375,129.9998,526.4375" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91.0001" x="145.8013" y="474.106">&#22788;&#29702;&#23458;&#25143;&#31471;&#35831;&#27714;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="130.6031" x="125.9998" y="489.2388">&#21629;&#20196;&#36861;&#21152;AOF&#32531;&#20914;&#21306;&#12289;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91.6031" x="145.4998" y="504.3716">AOF&#37325;&#20889;&#32531;&#20914;&#21306;</text></g><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="551.5703" y2="551.5703"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="551.5703" y2="564.5703"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="564.5703" y2="564.5703"/><polygon fill="#181818" points="129.9998,560.5703,119.9998,564.5703,129.9998,568.5703" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="312.0003" x="125.9998" y="546.5044">&#21019;&#24314;&#25991;&#20214;&#20107;&#20214;&#65292;&#29992;&#20110;&#29238;&#23376;&#36827;&#31243;&#31649;&#36947;&#20256;&#36755;&#37325;&#20889;&#32531;&#20914;&#21306;&#25968;&#25454;</text></g><g class="message" data-participant-1="Main" data-participant-2="Child"><polygon fill="#181818" points="433.0001,589.7031,443.0001,593.7031,433.0001,597.7031" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="439.0001" y1="593.7031" y2="593.7031"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="64.4034" x="249.7983" y="588.6372">fork&#23376;&#36827;&#31243;</text></g><g class="message" data-participant-1="Child" data-participant-2="Child"><line style="stroke:#181818;stroke-width:1;" x1="445.0001" x2="487.0001" y1="622.8359" y2="622.8359"/><line style="stroke:#181818;stroke-width:1;" x1="487.0001" x2="487.0001" y1="622.8359" y2="635.8359"/><line style="stroke:#181818;stroke-width:1;" x1="446.0001" x2="487.0001" y1="635.8359" y2="635.8359"/><polygon fill="#181818" points="456.0001,631.8359,446.0001,635.8359,456.0001,639.8359" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="104.6031" x="452.0001" y="617.77">&#36827;&#34892;AOF&#37325;&#20889;&#24037;&#20316;</text></g><g class="message" data-participant-1="Child" data-participant-2="Child"><line style="stroke:#181818;stroke-width:1;" x1="445.0001" x2="487.0001" y1="680.1016" y2="680.1016"/><line style="stroke:#181818;stroke-width:1;" x1="487.0001" x2="487.0001" y1="680.1016" y2="693.1016"/><line style="stroke:#181818;stroke-width:1;" x1="446.0001" x2="487.0001" y1="693.1016" y2="693.1016"/><polygon fill="#181818" points="456.0001,689.1016,446.0001,693.1016,456.0001,697.1016" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78.0001" x="507.8087" y="659.9028">&#21019;&#24314;&#20020;&#26102;&#25991;&#20214;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="189.6172" x="452.0001" y="675.0356">(temp-rewriteaof-${pid}.aof)</text></g><path d="M377.0002,708.1016 L441.4431,708.1016 L441.4431,715.2344 L431.4431,725.2344 L377.0002,725.2344 L377.0002,708.1016" fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="131.3359" style="stroke:#000000;stroke-width:1.5;" width="295.0002" x="377.0002" y="708.1016"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="19.4429" x="392.0002" y="721.1685">alt</text><text fill="#000000" font-family="sans-serif" font-size="11" font-weight="bold" lengthAdjust="spacing" textLength="87.0542" x="456.4431" y="720.312">[&#21551;&#29992;&#28151;&#21512;&#25345;&#20037;&#21270;]</text><g class="message" data-participant-1="Child" data-participant-2="Child"><line style="stroke:#181818;stroke-width:1;" x1="445.0001" x2="487.0001" y1="761.5" y2="761.5"/><line style="stroke:#181818;stroke-width:1;" x1="487.0001" x2="487.0001" y1="761.5" y2="774.5"/><line style="stroke:#181818;stroke-width:1;" x1="446.0001" x2="487.0001" y1="774.5" y2="774.5"/><polygon fill="#181818" points="456.0001,770.5,446.0001,774.5,456.0001,778.5" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="99.8487" x="467.6979" y="741.3013">&#25191;&#34892;rdb&#21518;&#21488;&#37325;&#20889;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="131.2442" x="452.0001" y="756.4341">&#36890;&#36807;BGSAVE&#26041;&#24335;&#20445;&#23384;</text></g><line style="stroke:#000000;stroke-width:1;stroke-dasharray:2.0,2.0;" x1="377.0002" x2="672.0004" y1="783.5" y2="783.5"/><text fill="#000000" font-family="sans-serif" font-size="11" font-weight="bold" lengthAdjust="spacing" textLength="79.4328" x="382.0002" y="793.7104">[&#26222;&#36890;AOF&#37325;&#20889;]</text><g class="message" data-participant-1="Child" data-participant-2="Child"><line style="stroke:#181818;stroke-width:1;" x1="445.0001" x2="487.0001" y1="818.4375" y2="818.4375"/><line style="stroke:#181818;stroke-width:1;" x1="487.0001" x2="487.0001" y1="818.4375" y2="831.4375"/><line style="stroke:#181818;stroke-width:1;" x1="446.0001" x2="487.0001" y1="831.4375" y2="831.4375"/><polygon fill="#181818" points="456.0001,827.4375,446.0001,831.4375,456.0001,835.4375" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="208.0002" x="452.0001" y="813.3716">&#36941;&#21382;&#25968;&#25454;&#24211;&#20889;&#20837;&#25152;&#26377;&#38190;&#20540;&#21450;&#36807;&#26399;&#26102;&#38388;</text></g><g class="message" data-participant-1="Child" data-participant-2="Child"><line style="stroke:#181818;stroke-width:1;" x1="445.0001" x2="487.0001" y1="882.7031" y2="882.7031"/><line style="stroke:#181818;stroke-width:1;" x1="487.0001" x2="487.0001" y1="882.7031" y2="895.7031"/><line style="stroke:#181818;stroke-width:1;" x1="446.0001" x2="487.0001" y1="895.7031" y2="895.7031"/><polygon fill="#181818" points="456.0001,891.7031,446.0001,895.7031,456.0001,899.7031" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="130.0002" x="465.3016" y="862.5044">&#36890;&#36807;&#29238;&#23376;&#36827;&#31243;&#31649;&#36947;&#25509;&#25910;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="156.6032" x="452.0001" y="877.6372">&#36951;&#28431;&#30340;AOF&#37325;&#20889;&#32531;&#20914;&#21306;&#25968;&#25454;</text></g><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="939.9688" y2="939.9688"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="939.9688" y2="952.9688"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="952.9688" y2="952.9688"/><polygon fill="#181818" points="129.9998,948.9688,119.9998,952.9688,129.9998,956.9688" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117.0001" x="125.9998" y="919.77">&#29238;&#36827;&#31243;&#20572;&#27490;&#31649;&#36947;&#20256;&#36755;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="104.0001" x="132.4998" y="934.9028">&#21457;&#36865;&#32467;&#26463;&#26631;&#24535;&#25968;&#25454;</text></g><g class="message" data-participant-1="Child" data-participant-2="Child"><line style="stroke:#181818;stroke-width:1;" x1="445.0001" x2="487.0001" y1="982.1016" y2="982.1016"/><line style="stroke:#181818;stroke-width:1;" x1="487.0001" x2="487.0001" y1="982.1016" y2="995.1016"/><line style="stroke:#181818;stroke-width:1;" x1="446.0001" x2="487.0001" y1="995.1016" y2="995.1016"/><polygon fill="#181818" points="456.0001,991.1016,446.0001,995.1016,456.0001,999.1016" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="286.6033" x="452.0001" y="977.0356">&#23558;&#25968;&#25454;&#20889;&#20837;&#20020;&#26102;&#25991;&#20214;&#65292;&#20889;&#23436;&#37325;&#21629;&#21517;&#20026;&#27491;&#24335;AOF&#25991;&#20214;</text></g><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="1039.3672" y2="1039.3672"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="1039.3672" y2="1052.3672"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="1052.3672" y2="1052.3672"/><polygon fill="#181818" points="129.9998,1048.3672,119.9998,1052.3672,129.9998,1056.3672" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="130.6031" x="125.9998" y="1019.1685">&#23558;AOF&#37325;&#20889;&#32531;&#20914;&#21306;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="104.6031" x="138.9998" y="1034.3013">&#36861;&#21152;&#21040;&#26032;AOF&#25991;&#20214;</text></g><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="1081.5" y2="1081.5"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="1081.5" y2="1094.5"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="1094.5" y2="1094.5"/><polygon fill="#181818" points="129.9998,1090.5,119.9998,1094.5,129.9998,1098.5" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="182.6032" x="125.9998" y="1076.4341">&#21407;&#23376;&#26367;&#25442;&#26087;AOF&#25991;&#20214;&#65292;&#26356;&#26032;&#20449;&#24687;</text></g><g class="message" data-participant-1="Main" data-participant-2="Main"><line style="stroke:#181818;stroke-width:1;" x1="118.9998" x2="160.9998" y1="1123.6328" y2="1123.6328"/><line style="stroke:#181818;stroke-width:1;" x1="160.9998" x2="160.9998" y1="1123.6328" y2="1136.6328"/><line style="stroke:#181818;stroke-width:1;" x1="119.9998" x2="160.9998" y1="1136.6328" y2="1136.6328"/><polygon fill="#181818" points="129.9998,1132.6328,119.9998,1136.6328,129.9998,1140.6328" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="169.0002" x="125.9998" y="1118.5669">&#28165;&#31354;&#32531;&#20914;&#21306;&#12289;&#21024;&#38500;&#20020;&#26102;&#25991;&#20214;&#31561;</text></g><!--SRC=[ZLHTRz9G6BxlhsWMB_HYJcEyyS9akBdimhZCHM-ugQERpQ0ZfOipneIQyRNn6HZ8O0xcvb33XsO11aL-ZEUSjbVx2xxGqRK3mIOjv9pdVTxdVT_d7Cy6nxiPWN7H7l6TauMlmAsAMoudvJ5sbXX1v5OvDyEBIup3mV7hz8DxfdtRvlPW_Vv3q_eSkyPiESKLTbkSTNBhl8lbHNeLFgn0KUvhKdeADTkNSb09rY_baDhDAQMzAPhnqCyOZhS2SJbksd_oXdCwAAe7ewSVz-7q8zgsi3p_QdbnPNxs-LEAOfmYRKIHyXUSBv7GcLeCmwuMY61_bgBXkS6XTbCuzrbBPTLg5NMBHAfIhDF3qgWPmULFm6546znz6ZrR3x0yPvi1q0mf5V5XneeQaP24agYvIme1jUg_bCFeOW_7ewYrXzfrr2ohPrznB64fhCVHbqGo1UohetPwOWwT1OA16iTgfkgjqWqYxF-bV9SCnF_rQO0qn4qaMTiKDeR5ZyfMgU7ElW5Td5FAeHjPHqJXanqbxiULOn9iA3-gQhL1VdwqypZHGUqJjTl1kmNeYI8dGIaEj_vu9JjlZDTO7fiXcCFj5aa7UjFgpmn6gAHAg1K5JnjwbKfHav98BgY_apVOoNwDH2hKo2Hzbm-roGBL8IOiWCmMnurJrCcF3z6BGCrpagdhfTZvsoBhSayBx5k14rbcSstwrditv_Xm5_xUiIhekoTUXQ99eu7ZGHAMq8KFXzCMrCZ4-d4K7A_DjhJpclT0xGPi2ozcNywJz0MMOwXx20Qr4EecorO0R3tFOpDgKWH7_NhFSIlPQv3lb8Iy91_IKXNibN5i5tAJ_17qGikSMrFoZWdDrvKFJvv4JqaAkgf96IB7b8ETOPUDyy6LsO3twdHAUL8-DfiAJ1rBQ5v9QIV9uH5S9hYR6SKuFFlQe1lzLfXD04xkBLR2FQM93ev7KBFLkqVb6CZNCMFr0lU_whJp-l73mHf9rwxfnh55Zw2h9DSbaMEIEJDYG2R9dGFBvFk0D7tAjvRvlEDWGSkUcAk6YuKo3tpm2-zV]--></g></svg><p>更新过程细节</p><ul><li>创建子进程 fork 构建一个新的aof</li><li>子进程读取当前redis的数据，写入到新的aof 文件中</li><li>读取redis数据期间，主进程其他新增的写入操作，会被写入aof_buffer, aof_rewrite_buffer 缓存中；</li><li>重写完成后，将aof_rewrite_buffer 缓存追加写入到新的aof中</li><li>用新的aof覆盖现有的 aof 文件；</li><li>问题：<ul><li>高并发情况下，AOF重写缓冲区积累可能会很大，这样就会造成阻塞</li><li>Redis后来通过Linux管道技术让aof重写期间就能同时进行回放，这样aof重写结束后只需回放少量剩余的数据即可。</li></ul></li></ul><h3 id="重写日志的过程中可能阻塞的情况"><a href="#重写日志的过程中可能阻塞的情况" class="headerlink" title="重写日志的过程中可能阻塞的情况"></a>重写日志的过程中可能阻塞的情况</h3><ul><li>fork 子进程，拷贝页表，可能阻塞</li><li>主进程写入大 key 时，由于写时拷贝（COW），会导致主线程阻塞</li><li>子进程重写日志完成后，主进程追加写入rewrite-aof-buffer时，可能对于主线程存在阻塞；</li></ul><h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><ul><li>混合持久化发生于aof重写的过程中，使用混合持久化，重写后新的aof文件前半段为 rdb格式的全量数据，后半段是aof格式的增量数据；<ul><li>整体格式 [rdb file] [aof tail]</li></ul></li><li>混合持久化本质是通过 aof 后台重写完成的，不同的是当开启混合持久化时，fork出的子进程先将当前的全量数据以rdb的方式写入新的aof文件；然后再将 AOF 重写缓冲区（aof_rewrite_buf_blocks）的增量命令以 AOF 方式写入到文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</li><li>优点<ul><li>结合了rdb和aof 的优点，更快的恢复和重写</li></ul></li><li>缺点<ul><li>aof文件里面的rdb不再是aof格式，可读性差</li></ul></li></ul><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>适用于既要求高恢复速度又要求较高数据安全性的混合型业务场景。</li><li>适合大数据量、对冷启动恢复时间敏感、同时又希望减少AOF重写期间阻塞的业务。</li><li>适合对持久化文件体积和恢复效率有双重要求的企业级应用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>persistence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2025/04/21/redis/struct/"/>
    <url>/2025/04/21/redis/struct/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis的底层数据结构设计（高效背后的秘密）"><a href="#Redis的底层数据结构设计（高效背后的秘密）" class="headerlink" title="Redis的底层数据结构设计（高效背后的秘密）"></a>Redis的底层数据结构设计（高效背后的秘密）</h1><h2 id="SDS-Simple-Dynamic-String-（简单动态字符串）"><a href="#SDS-Simple-Dynamic-String-（简单动态字符串）" class="headerlink" title="SDS(Simple Dynamic String)（简单动态字符串）"></a>SDS(Simple Dynamic String)（简单动态字符串）</h2><ul><li>C风格的字符串 + length + capacity； struct SDS<T> 不同的数据类型使用不同的结构：int，embstr，raw<ul><li>长度小于等于 44 字节为 embstr，大于 44 字节变为 raw 存储</li><li>44字节的来源 :64 （jemalloc 分配，超过64不使用embstr)-16（redis object头部大小）-3（至少3字节的length+capacity，int8）- 1字符串以’\0’结尾</li></ul></li><li>扩容策略<ul><li>字符串小于1M，扩容策略加倍，超过1M，每次多分配1M，防止冗余；</li></ul></li><li>优点：<ul><li>不仅可以保存文本数据，还可以保存二进制数据（length取代了\0结束符）</li><li>获取字符串长度的时间复杂度是 O(1)</li><li>SDS API 是安全的，拼接字符串不会造成缓冲区溢出，增加了缓冲</li><li>兼容C字符串函数</li></ul></li></ul><h2 id="Hash（哈希字典）"><a href="#Hash（哈希字典）" class="headerlink" title="Hash（哈希字典）"></a>Hash（哈希字典）</h2><ul><li>本质：数组+链表，利用链地址法解决哈希冲突<ul><li>小型的Hash会退化成ListPack（低版本zipList）节省内存</li></ul></li><li>哈希冲突：按照 key 值进行hash计算，得到存储的数字索引，根据索引获取链表进行处理；</li><li>渐进式Hash<ul><li>当元素个数增长，哈希冲突严重影响查询效率；Redis保证引用高性能运行，引入渐进式hash进行扩缩容；</li><li>扩容：<ul><li>元素数量等于当前的数组长度，进行扩容；会申请一个新的内存地址，将rehashindex设置为0，标志开始进行rehash操作</li><li>当前服务器没有执行bgsave&#x2F;bgrewriteaof，并且负载因子为1</li><li>服务器正在执行 bgsave&#x2F;bgrewriteaof，负载因子等于5</li></ul></li><li>缩容<ul><li>当字典的使用容量不足总空间的 10% 时就会触发缩容，Redis 在进行缩容时也会把 rehashindex 设置为 0，表示之后需要进行 rehash 操作。</li></ul></li><li>流程<ul><li>渐进式hash时，同时保留两个hash结构，新的键值对直接插入新的hash结构，并将旧hash结构一点点移动到新的hash结构中；移除完结构后，清空旧的hash结构；<ul><li>扩容或者缩容时把字典中的字段 rehashidx 标识为 0；</li><li>在执行定时任务或者执行客户端的 hset、hdel 等操作指令时，判断是否需要触发 rehash 操作（通过 rehashidx 标识判断），如果需要触发 rehash 操作，也就是调用 dictRehash 函数，dictRehash 函数会把 ht[0] 中的元素依次添加到新的 Hash 表 ht[1] 中;一次只迁移一个数组元素；</li><li>rehash 操作完成之后，清空 Hash 表 ht[0]，然后对调 ht[1] 和 ht[0] 的值，把新的数据表 ht[1] 更改为 ht[0]，然后把字典中的 rehashidx 标识为 -1，表示不需要执行 rehash 操作。</li></ul></li><li>渐进式 rehash 期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行增加操作，一定是在新的哈希表上进行的。 分摊扩缩容操作的开销；</li></ul></li><li>如果一次全部迁移的话，可能会导致系统阻塞；</li></ul></li></ul><h2 id="ZipList（压缩链表）–-逐步废弃"><a href="#ZipList（压缩链表）–-逐步废弃" class="headerlink" title="ZipList（压缩链表）– 逐步废弃"></a>ZipList（压缩链表）– 逐步废弃</h2><ul><li>当Zset，Hash，List底层元素较少时，使用ZipList进行存储，提高内存的利用率；</li><li>存储是一块连续的内存空间，元素之间是相邻的，没有冗余空隙，小端序存储<ul><li><code>&lt;zlbytes&gt;&lt;ztail&gt;&lt;zllen&gt;&lt;entry&gt;...&lt;entry&gt;&lt;zlend&gt;</code> NOTE: 小端序存储</li><li>zlbytes: uint32，存储ziplist占用大小</li><li>zltail: uint32, 最后一个条目的偏移量</li><li>zllen: uint16, 条目数量</li><li>zlend: uint8, 标记ziplist结尾</li><li>entry结构:<code>&lt;prelen&gt;&lt;encoding&gt;&lt;entry-data&gt;</code><ul><li>prelen：前一个entry的字节长度，倒序遍历定位</li><li>encoding：元素类型编码(int<var>)</li><li>entry-data：entry数据，长度和对应的内容指针</li><li><a href="https://github.com/redis/redis/blob/unstable/src/ziplist.c">具体结构体定义zlentry</a></li></ul></li></ul></li><li><font color='red'>级联更新问题</font>：更新某个元素的占用大小，需要访问每个节点<ul><li>扩大：可能导致，1byte-&gt;5byte，某个节点更新了大小，导致后面节点更新prelen占用的大小；因为ziplist是连续内存（紧凑的），导致该节点后续的所有元素都需要更新大小；</li><li>缩小：不处理，依然可以确定前置的长度；</li></ul></li><li>删除&#x2F;新增元素：导致局部重写</li><li>IntSet：小整数集合<ul><li>当Set集合容纳的元素都是整数并且元素个数较小时，Redis使用intset来存储结合元素，intset是紧凑的数组结构，支持16，32，64位数；</li><li>不使用ziplist的原因，定长数组，不需要冗余长度字段</li></ul></li></ul><h2 id="QuickList：快速双向链表"><a href="#QuickList：快速双向链表" class="headerlink" title="QuickList：快速双向链表"></a>QuickList：快速双向链表</h2><ul><li>使用的结构：List</li><li>quickList是 zipList&#x2F;listPack 和 linkedList的合体<ul><li>每一段使用zipList&#x2F;listPack紧凑存储</li><li>使用双向指针串联起来</li></ul></li><li>quickList中zipList&#x2F;listPack 存储元素个数<ul><li>默认8K字节，通过参数 <code>list-max-listpack-size</code> &#x2F; <code>list-max-ziplist-size</code> 决定</li><li>压缩深度：代表首位的多少个node不压缩，为了支持快速的push&#x2F;pop操作，默认为0，<code>list-compress-depth</code> 决定</li></ul></li></ul><h2 id="SkipList-跳表"><a href="#SkipList-跳表" class="headerlink" title="SkipList 跳表"></a>SkipList 跳表</h2><ul><li><p>使用的结构：Zset</p></li><li><p>Zset实现：Hash字典+跳表</p></li><li><p>redis的跳表默认最大32层，每个kv块对应的结构如代码中的zskiplistNode结构</p><ul><li>kv header也是这个结构，但是value是null值，score是 Double.MIN_VALUE，用来垫底</li><li>kv 之间使用指针串联形成双向链表结构，是有序排列的，从小到大；不用的kv层高可能不一样，层数越高的kv越少</li><li>统一层的kv会使用指针连接起来了，每一层元素的遍历都是从kv-header出发；</li></ul></li><li><p>查找事件复杂度：O(logN)</p></li><li><p>插入过程</p><ul><li>插入链表合适的位置</li><li>随机晋升（1&#x2F;4），得到最大的层数（不能超过最大层数+1）；</li><li>创建对应层数的节点，更新节点前后的指针；</li></ul></li><li><p>删除过程</p><ul><li>找到每层的相关节点，更新对应指针和最高层数，释放资源</li></ul></li><li><p>更新过程</p><ul><li>获取节点的所有层数对应的指针，判断位置是否改变，未改变直接替换之前的score，位置变化了，就删除节点，当新节点重新插入；</li></ul></li><li><p>NOTE：</p><ul><li>Rank如何快速获取：每个阶段对应的Level数组中<strong>span</strong>记录了不同层前面节点的个数</li><li><strong>zset的score值相同：zset使用key的值进行排序了（sdscmp进行比较）</strong></li></ul><h2 id="ListPack紧凑列表（取代zipList）（内存连续"><a href="#ListPack紧凑列表（取代zipList）（内存连续" class="headerlink" title="ListPack紧凑列表（取代zipList）（内存连续"></a>ListPack紧凑列表（取代zipList）（内存连续</h2><ul><li>解决ZipList的级联更新问题</li><li>结构<ul><li><code>&lt;tot-bytes&gt;&lt;num-element&gt;&lt;element&gt;...&lt;element&gt;&lt;listpack-end-byte&gt;</code></li><li>element 结构：<code>&lt;encoding-type&gt;&lt;element-data&gt;&lt;element-tot-len&gt;</code></li></ul></li><li>为了避免zipList的级联更新问题， 就是隔离不同的entry,每个entry没有关联关系，利用entry本身的element-tot-len进行大小的判断，还是会存在的内存移动的问题<ul><li>解决方案：element-tot-len记录了这个element的长度（encoding + data），注意并不包括 element-tot-len 自身的长度，占用的字节数小于等于5</li><li><strong>如何判断长度字段是否结束？</strong>，element-tot-len 所占用的每个字节的<font color='red'><strong>第一个 bit 用于标识</strong></font>；0代表结束，1代表尚未结束，每个字节只有7bit 有效。Varint编码</li></ul></li><li>正向查询：<ul><li>保存了LP_HDR_SIZE 固定长度（6字节）的头部信息，4字节记录字节数，2字节记录元素个数；</li></ul></li><li>反向查询：<ul><li>利用 element-tot-len (大端序存储)，低位高地址</li></ul></li></ul></li></ul><h2 id="Steam-底层数据结构-RadixTree-ListPack"><a href="#Steam-底层数据结构-RadixTree-ListPack" class="headerlink" title="Steam 底层数据结构 RadixTree + ListPack"></a>Steam 底层数据结构 RadixTree + ListPack</h2><ul><li>RedixTree: 基数树，存储有序集合，存储streamID</li><li>ListPack: 紧凑列表，存储消息体</li><li>结构：<ul><li><code>&lt;stream-id&gt;&lt;stream-id-len&gt;&lt;stream-len&gt;&lt;group-name&gt;&lt;group-name-len&gt;&lt;consumer-name&gt;&lt;consumer-name-len&gt;&lt;message-id&gt;&lt;message-id-len&gt;&lt;message-body&gt;&lt;message-body-len&gt;</code></li><li>每个元素的长度都使用varint编码</li></ul></li><li>支持消费组&#x2F;支持多消费者，支持快速消费</li><li>支持接收方确认机制，可以限制队列的最大长度</li></ul><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><ul><li>用于统计基数（不重复元素的个数）</li><li>原理：<ul><li>利用hash函数将元素映射到一个固定的区间，然后利用bitmap进行标记，统计1的个数；</li><li>当元素个数较少时，使用bitmap进行标记，当元素个数较多时，使用多个hash函数进行标记，然后利用调和平均数进行估计；</li></ul></li></ul><h2 id="Geohash"><a href="#Geohash" class="headerlink" title="Geohash"></a>Geohash</h2><ul><li>用于存储地理位置信息</li><li>原理：<ul><li>将二维的经纬度转换为一维的字符串，然后利用字符串进行存储；</li><li>利用字符串进行排序，然后利用二分查找进行查询；</li><li>利用字符串进行范围查询；</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis是什么？为什么这么快？</title>
    <link href="/2025/04/21/redis/basic/"/>
    <url>/2025/04/21/redis/basic/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis是什么？为什么这么快？"><a href="#Redis是什么？为什么这么快？" class="headerlink" title="Redis是什么？为什么这么快？"></a>Redis是什么？为什么这么快？</h1><p>在如今这个对响应速度要求极高的技术时代，Redis 的出现像是一针强心剂：它简单、快、功能强大，几乎成了后端开发中的“性能神器”。但 Redis 真正的魅力，远不止“做缓存”这么简单。</p><p>本篇作为 Redis 系列的开篇文章，我们将从原理角度拆解 Redis 为什么快，以及它是如何凭借设计上的巧思，成为高性能场景下的不二之选。</p><h2 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h2><p>Redis（Remote Dictionary Server） 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供多种数据结构的支持<ul><li>List</li><li>Set</li><li>Sorted Set（ZSet）</li><li>Hash</li><li>HyperLogLog，Bitmap，Stream</li></ul></li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><p>常用于：</p><ul><li>缓存系统</li><li>消息中间件</li><li>排行榜&#x2F;计数器</li><li>地图计算</li><li>签到系统</li></ul><h2 id="Redis-为什么快？"><a href="#Redis-为什么快？" class="headerlink" title="Redis 为什么快？"></a>Redis 为什么快？</h2><p><a href="https://redis.io/docs/latest/operate/oss_and_stack/management/optimization/benchmarks/">Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s </a></p><h3 id="基于内存操作"><a href="#基于内存操作" class="headerlink" title="基于内存操作"></a>基于内存操作</h3><p>Redis 的数据都是保存在内存中的，读写不涉及磁盘（持久化异步线程）</p><h3 id="单线程架构-IO多路复用"><a href="#单线程架构-IO多路复用" class="headerlink" title="单线程架构+IO多路复用"></a>单线程架构+IO多路复用</h3><h4 id="单线程架构：（不代表只有一个线程）"><a href="#单线程架构：（不代表只有一个线程）" class="headerlink" title="单线程架构：（不代表只有一个线程）"></a>单线程架构：（不代表只有一个线程）</h4><ul><li>所有命令执行是串行的，具有天然的原子性<font color='red'><strong>（无锁）</strong></font></li><li>有其他后台线程处理其他任务<ul><li>关闭文件</li><li>AOF刷盘</li><li>异步释放内存</li></ul></li><li>6.0之后多线程处理网络IO任务</li></ul><h4 id="Epoll：IO多路复用，中断机制"><a href="#Epoll：IO多路复用，中断机制" class="headerlink" title="Epoll：IO多路复用，中断机制"></a>Epoll：IO多路复用，中断机制</h4><ul><li>Epoll + 非阻塞IO：可以处理大量的连接</li></ul><p>其他多路复用：</p><ul><li>select：遍历获取准备好的文件描述符，上限1024个，数组中；</li><li>poll：遍历获取准备好的文件描述符，无上限，文件描述符放入链表中；<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="SEQUENCE" height="878px" preserveAspectRatio="none" style="width:894px;height:878px;background:#FFFFFF;" version="1.1" viewBox="0 0 894 878" width="894px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="77.3984" style="stroke:#000000;stroke-width:1.5;" width="646.0749" x="165.2654" y="544.0234"/><g><title>&#23458;&#25143;&#31471;</title><rect fill="#000000" fill-opacity="0.00000" height="716.7891" width="8" x="24.9999" y="81.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="28" x2="28" y1="81.2969" y2="798.0859"/></g><g><title>listen socket</title><rect fill="#000000" fill-opacity="0.00000" height="716.7891" width="8" x="110.1326" y="81.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="113.9998" x2="113.9998" y1="81.2969" y2="798.0859"/></g><g><title>epoll_wait</title><rect fill="#000000" fill-opacity="0.00000" height="716.7891" width="8" x="213.3919" y="81.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="217.2654" x2="217.2654" y1="81.2969" y2="798.0859"/></g><g><title>&#20107;&#20214;&#20998;&#21457;&#22120;</title><rect fill="#000000" fill-opacity="0.00000" height="716.7891" width="8" x="315.392" y="81.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="318.3922" x2="318.3922" y1="81.2969" y2="798.0859"/></g><g><title>&#36830;&#25509;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;</title><rect fill="#000000" fill-opacity="0.00000" height="716.7891" width="8" x="443.3921" y="81.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="446.3924" x2="446.3924" y1="81.2969" y2="798.0859"/></g><g><title>&#35835;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;</title><rect fill="#000000" fill-opacity="0.00000" height="716.7891" width="8" x="572.3917" y="81.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="575.3919" x2="575.3919" y1="81.2969" y2="798.0859"/></g><g><title>&#20889;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;</title><rect fill="#000000" fill-opacity="0.00000" height="716.7891" width="8" x="741.3405" y="81.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="744.3407" x2="744.3407" y1="81.2969" y2="798.0859"/></g><g><title>&#21457;&#36865;&#38431;&#21015;</title><rect fill="#000000" fill-opacity="0.00000" height="716.7891" width="8" x="843.3406" y="81.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="846.3407" x2="846.3407" y1="81.2969" y2="798.0859"/></g><g class="participant participant-head" data-participant="&#23458;&#25143;&#31471;"><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="41.9998" x="5" y="77.9951">&#23458;&#25143;&#31471;</text><ellipse cx="28.9999" cy="13.5" fill="#E2E2F0" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M28.9999,21.5 L28.9999,48.5 M15.9999,29.5 L41.9999,29.5 M28.9999,48.5 L15.9999,63.5 M28.9999,48.5 L41.9999,63.5" fill="none" style="stroke:#181818;stroke-width:0.5;"/></g><g class="participant participant-tail" data-participant="&#23458;&#25143;&#31471;"><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="41.9998" x="5" y="810.0811">&#23458;&#25143;&#31471;</text><ellipse cx="28.9999" cy="821.8828" fill="#E2E2F0" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M28.9999,829.8828 L28.9999,856.8828 M15.9999,837.8828 L41.9999,837.8828 M28.9999,856.8828 L15.9999,871.8828 M28.9999,856.8828 L41.9999,871.8828" fill="none" style="stroke:#181818;stroke-width:0.5;"/></g><g class="participant participant-head" data-participant="Listen"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="102.2656" x="62.9998" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="88.2656" x="69.9998" y="69.9951">listen socket</text></g><g class="participant participant-tail" data-participant="Listen"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="102.2656" x="62.9998" y="797.0859"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="88.2656" x="69.9998" y="817.0811">listen socket</text></g><g class="participant participant-head" data-participant="Epoll"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="84.2529" x="175.2654" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="70.2529" x="182.2654" y="69.9951">epoll_wait</text></g><g class="participant participant-tail" data-participant="Epoll"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="84.2529" x="175.2654" y="797.0859"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="70.2529" x="182.2654" y="817.0811">epoll_wait</text></g><g class="participant participant-head" data-participant="Dispatcher"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="83.9997" x="277.3922" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="69.9997" x="284.3922" y="69.9951">&#20107;&#20214;&#20998;&#21457;&#22120;</text></g><g class="participant participant-tail" data-participant="Dispatcher"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="83.9997" x="277.3922" y="797.0859"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="69.9997" x="284.3922" y="817.0811">&#20107;&#20214;&#20998;&#21457;&#22120;</text></g><g class="participant participant-head" data-participant="ConnHandler"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="125.9995" x="384.3924" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="111.9995" x="391.3924" y="69.9951">&#36830;&#25509;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;</text></g><g class="participant participant-tail" data-participant="ConnHandler"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="125.9995" x="384.3924" y="797.0859"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="111.9995" x="391.3924" y="817.0811">&#36830;&#25509;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;</text></g><g class="participant participant-head" data-participant="ReadHandler"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="111.9996" x="520.3919" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="97.9996" x="527.3919" y="69.9951">&#35835;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;</text></g><g class="participant participant-tail" data-participant="ReadHandler"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="111.9996" x="520.3919" y="797.0859"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="97.9996" x="527.3919" y="817.0811">&#35835;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;</text></g><g class="participant participant-head" data-participant="WriteHandler"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="111.9996" x="689.3407" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="97.9996" x="696.3407" y="69.9951">&#20889;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;</text></g><g class="participant participant-tail" data-participant="WriteHandler"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="111.9996" x="689.3407" y="797.0859"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="97.9996" x="696.3407" y="817.0811">&#20889;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;</text></g><g class="participant participant-head" data-participant="SendQueue"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="69.9998" x="812.3407" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="55.9998" x="819.3407" y="69.9951">&#21457;&#36865;&#38431;&#21015;</text></g><g class="participant participant-tail" data-participant="SendQueue"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="69.9998" x="812.3407" y="797.0859"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="55.9998" x="819.3407" y="817.0811">&#21457;&#36865;&#38431;&#21015;</text></g><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1;" width="887.3405" x="0" y="111.8633"/><line style="stroke:#000000;stroke-width:1;" x1="0" x2="887.3405" y1="111.8633" y2="111.8633"/><line style="stroke:#000000;stroke-width:1;" x1="0" x2="887.3405" y1="114.8633" y2="114.8633"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2;" width="70.5259" x="408.4073" y="101.2969"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="52.0001" x="414.4073" y="117.3638">&#36830;&#25509;&#24314;&#31435;</text><g class="message" data-participant-1="&#23458;&#25143;&#31471;" data-participant-2="Listen"><polygon fill="#181818" points="102.1326,151.5625,112.1326,155.5625,102.1326,159.5625,106.1326,155.5625" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="28.9999" x2="108.1326" y1="155.5625" y2="155.5625"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="52.0001" x="35.9999" y="150.4966">&#21457;&#36215;&#36830;&#25509;</text></g><g class="message" data-participant-1="Listen" data-participant-2="Epoll"><polygon fill="#181818" points="205.3919,180.6953,215.3919,184.6953,205.3919,188.6953,209.3919,184.6953" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="114.1326" x2="211.3919" y1="184.6953" y2="184.6953"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78.0001" x="121.1326" y="179.6294">&#35302;&#21457;&#36830;&#25509;&#20107;&#20214;</text></g><g class="message" data-participant-1="Epoll" data-participant-2="Dispatcher"><polygon fill="#181818" points="307.392,209.8281,317.392,213.8281,307.392,217.8281,311.392,213.8281" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="217.3919" x2="313.392" y1="213.8281" y2="213.8281"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78.0001" x="224.3919" y="208.7622">&#21457;&#29616;&#36830;&#25509;&#20107;&#20214;</text></g><g class="message" data-participant-1="Dispatcher" data-participant-2="ConnHandler"><polygon fill="#181818" points="435.3921,238.9609,445.3921,242.9609,435.3921,246.9609,439.3921,242.9609" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="319.392" x2="441.3921" y1="242.9609" y2="242.9609"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="104.0001" x="326.392" y="237.895">&#35843;&#29992;&#36830;&#25509;&#22788;&#29702;&#20989;&#25968;</text></g><g class="message" data-participant-1="ConnHandler" data-participant-2="ConnHandler"><line style="stroke:#181818;stroke-width:1;" x1="447.3921" x2="489.3921" y1="272.0938" y2="272.0938"/><line style="stroke:#181818;stroke-width:1;" x1="489.3921" x2="489.3921" y1="272.0938" y2="285.0938"/><line style="stroke:#181818;stroke-width:1;" x1="448.3921" x2="489.3921" y1="285.0938" y2="285.0938"/><polygon fill="#181818" points="458.3921,281.0938,448.3921,285.0938,458.3921,289.0938,454.3921,285.0938" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="73.7408" x="454.3921" y="267.0278">accept &#36830;&#25509;</text></g><g class="message" data-participant-1="ConnHandler" data-participant-2="Epoll"><polygon fill="#181818" points="228.3919,310.2266,218.3919,314.2266,228.3919,318.2266,224.3919,314.2266" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="222.3919" x2="446.3921" y1="314.2266" y2="314.2266"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="128.7623" x="234.3919" y="309.1606">&#27880;&#20876; socket &#21644;&#35835;&#20107;&#20214;</text></g><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1;" width="887.3405" x="0" y="342.793"/><line style="stroke:#000000;stroke-width:1;" x1="0" x2="887.3405" y1="342.793" y2="342.793"/><line style="stroke:#000000;stroke-width:1;" x1="0" x2="887.3405" y1="345.793" y2="345.793"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2;" width="70.5259" x="408.4073" y="332.2266"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="52.0001" x="414.4073" y="348.2935">&#35835;&#21462;&#21629;&#20196;</text><g class="message" data-participant-1="Epoll" data-participant-2="Dispatcher"><polygon fill="#181818" points="307.392,382.4922,317.392,386.4922,307.392,390.4922,311.392,386.4922" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="217.3919" x2="313.392" y1="386.4922" y2="386.4922"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65.0001" x="224.3919" y="381.4263">&#21457;&#29616;&#35835;&#20107;&#20214;</text></g><g class="message" data-participant-1="Dispatcher" data-participant-2="ReadHandler"><polygon fill="#181818" points="564.3917,411.625,574.3917,415.625,564.3917,419.625,568.3917,415.625" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="319.392" x2="570.3917" y1="415.625" y2="415.625"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117.0001" x="326.392" y="410.5591">&#35843;&#29992;&#35835;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;</text></g><g class="message" data-participant-1="ReadHandler" data-participant-2="ReadHandler"><line style="stroke:#181818;stroke-width:1;" x1="576.3917" x2="618.3917" y1="444.7578" y2="444.7578"/><line style="stroke:#181818;stroke-width:1;" x1="618.3917" x2="618.3917" y1="444.7578" y2="457.7578"/><line style="stroke:#181818;stroke-width:1;" x1="577.3917" x2="618.3917" y1="457.7578" y2="457.7578"/><polygon fill="#181818" points="587.3917,453.7578,577.3917,457.7578,587.3917,461.7578,583.3917,457.7578" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="59.6934" x="583.3917" y="439.6919">read &#25968;&#25454;</text></g><g class="message" data-participant-1="ReadHandler" data-participant-2="ReadHandler"><line style="stroke:#181818;stroke-width:1;" x1="576.3917" x2="618.3917" y1="486.8906" y2="486.8906"/><line style="stroke:#181818;stroke-width:1;" x1="618.3917" x2="618.3917" y1="486.8906" y2="499.8906"/><line style="stroke:#181818;stroke-width:1;" x1="577.3917" x2="618.3917" y1="499.8906" y2="499.8906"/><polygon fill="#181818" points="587.3917,495.8906,577.3917,499.8906,587.3917,503.8906,583.3917,499.8906" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="123.1573" x="583.3917" y="481.8247">&#35299;&#26512;&#21629;&#20196; + &#25191;&#34892;&#21629;&#20196;</text></g><g class="message" data-participant-1="ReadHandler" data-participant-2="SendQueue"><polygon fill="#181818" points="835.3406,525.0234,845.3406,529.0234,835.3406,533.0234,839.3406,529.0234" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="576.3917" x2="841.3406" y1="529.0234" y2="529.0234"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117.0001" x="583.3917" y="523.9575">&#28155;&#21152;&#21709;&#24212;&#21040;&#21457;&#36865;&#38431;&#21015;</text></g><path d="M165.2654,544.0234 L229.7083,544.0234 L229.7083,551.1563 L219.7083,561.1563 L165.2654,561.1563 L165.2654,544.0234" fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="77.3984" style="stroke:#000000;stroke-width:1.5;" width="646.0749" x="165.2654" y="544.0234"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="19.4429" x="180.2654" y="557.0903">alt</text><text fill="#000000" font-family="sans-serif" font-size="11" font-weight="bold" lengthAdjust="spacing" textLength="109.054" x="244.7083" y="556.2339">[&#26159;&#21542;&#38656;&#35201;&#31435;&#21363;&#21457;&#36865;&#65311;]</text><g class="message" data-participant-1="ReadHandler" data-participant-2="WriteHandler"><polygon fill="#181818" points="733.3405,578.2891,743.3405,582.2891,733.3405,586.2891,737.3405,582.2891" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="576.3917" x2="739.3405" y1="582.2891" y2="582.2891"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="144.9489" x="583.3917" y="577.2231">&#30452;&#25509;&#35843;&#29992; write &#21457;&#36865;&#25968;&#25454;</text></g><line style="stroke:#000000;stroke-width:1;stroke-dasharray:2.0,2.0;" x1="165.2654" x2="811.3403" y1="591.2891" y2="591.2891"/><g class="message" data-participant-1="ReadHandler" data-participant-2="Epoll"><polygon fill="#181818" points="228.3919,609.4219,218.3919,613.4219,228.3919,617.4219,224.3919,613.4219" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="222.3919" x2="575.3917" y1="613.4219" y2="613.4219"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65.0001" x="234.3919" y="608.356">&#27880;&#20876;&#20889;&#20107;&#20214;</text></g><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1;" width="887.3405" x="0" y="648.9883"/><line style="stroke:#000000;stroke-width:1;" x1="0" x2="887.3405" y1="648.9883" y2="648.9883"/><line style="stroke:#000000;stroke-width:1;" x1="0" x2="887.3405" y1="651.9883" y2="651.9883"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2;" width="57.5259" x="414.9073" y="638.4219"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="39" x="420.9073" y="654.4888">&#20889;&#21709;&#24212;</text><g class="message" data-participant-1="Epoll" data-participant-2="Dispatcher"><polygon fill="#181818" points="307.392,688.6875,317.392,692.6875,307.392,696.6875,311.392,692.6875" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="217.3919" x2="313.392" y1="692.6875" y2="692.6875"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65.0001" x="224.3919" y="687.6216">&#21457;&#29616;&#20889;&#20107;&#20214;</text></g><g class="message" data-participant-1="Dispatcher" data-participant-2="WriteHandler"><polygon fill="#181818" points="733.3405,717.8203,743.3405,721.8203,733.3405,725.8203,737.3405,721.8203" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="319.392" x2="739.3405" y1="721.8203" y2="721.8203"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117.0001" x="326.392" y="716.7544">&#35843;&#29992;&#20889;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;</text></g><g class="message" data-participant-1="WriteHandler" data-participant-2="SendQueue"><polygon fill="#181818" points="835.3406,746.9531,845.3406,750.9531,835.3406,754.9531,839.3406,750.9531" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="745.3405" x2="841.3406" y1="750.9531" y2="750.9531"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78.0001" x="752.3405" y="745.8872">&#36941;&#21382;&#21457;&#36865;&#38431;&#21015;</text></g><g class="message" data-participant-1="WriteHandler" data-participant-2="&#23458;&#25143;&#31471;"><polygon fill="#181818" points="39.9999,776.0859,29.9999,780.0859,39.9999,784.0859,35.9999,780.0859" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="33.9999" x2="744.3405" y1="780.0859" y2="780.0859"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="88.8165" x="45.9999" y="775.02">write &#21457;&#36865;&#25968;&#25454;</text></g><!--SRC=[XPFDRjD04CVl-nIZNX4lK2cz058FN813ZsZbh8I5vLZsLhqs0fb0yqbRQ0LgwGT9f4fDf0AHOYfU9cCxfxv2rrxZx3fkUzoPttyqyvzPQl2Q2tXv6ZOcqSM8EDJbfc4wrEQmOfaUPpPuDUCjuoj0FNYUHdIAEJNBUhr5JOayIvuwCPlkp88_sF2nqyF3OOezDJs7SkCDStKs_dSKjdzcYlFtKTV73zVX_ZWLFQdPzZgrgzQIQXJS8Nd9QBLKWlxX7P8Dr-IiNDFfpRVhyuDZR7nDqLVChhxOP9kCa4e5PEyOJAEB7QXKI6uhF5xBh8DL44NYtnF9aYmgygbl8XqF-WcXs41aIZ0BqsITg3tMG2KlQCMjfExuNRGtp5fKHYOgjgIYXi4SdarMHF-t75uDqMzcTmBukPclGzeo2h3p1NlNi-0yiUNUSNAbFekoniKiPKidAhaaTCKB11MsBky7uy5PUDJDUdu4uST1VDAKpw8mlu74YKc0dtxWRWkdUzWOg_T2gCKXF1XXjp__lXttw-98i7KbaPk_nmIWK5YzGr4x-lPBx42E3bj93gGucuTP7bikekyeFteYcawN8oAotOSsiv3gcobqAVih_Ln4GmlEpUijRFkQOKLyyPrMI-Q_1G00]--></g></svg></li></ul><h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><p>Redis的数据结构设计，进行了高度的优化，根据场景使用，保证更加的高效</p><ul><li>String（字符串）</li><li>Hash（哈希）</li><li>List（链表）</li><li>Set（集合）</li><li>Sorted Set（有序集合）</li><li>Stream（流）</li><li>Bitmap（位图）</li><li>BitField（位字段）</li><li>GeoSpatial（地理空间）</li><li>HyperLogLog（基数统计）</li></ul><a href="/2025/04/21/redis/struct/" title="数据结构">数据结构详解</a><h3 id="底层构建"><a href="#底层构建" class="headerlink" title="底层构建"></a>底层构建</h3><p>redis底层构建了 VM 机制，将冷数据交换到磁盘中，实现冷热分离，避免内存不足导致的访问速度下降；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redis的性能是架构和实现深层次的工程决策</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>insert_flow</title>
    <link href="/2025/04/15/mysql/insert-flow/"/>
    <url>/2025/04/15/mysql/insert-flow/</url>
    
    <content type="html"><![CDATA[<h1 id="MYSQL插入数据的完整过程"><a href="#MYSQL插入数据的完整过程" class="headerlink" title="MYSQL插入数据的完整过程"></a>MYSQL插入数据的完整过程</h1><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">客户端请求 → 建立连接 → 解析优化 → 事务开启 → 写Undo Log → 修改Buffer Pool →写Redo Log → 写Binlog → 两阶段提交 → 事务确认 → 脏页刷盘 → 持久化完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="客户端请求和连接"><a href="#客户端请求和连接" class="headerlink" title="客户端请求和连接"></a>客户端请求和连接</h2><ul><li>客户端发送SQL：用户发送 <code>INSERT</code> 语句到MYSQL服务器</li><li>连接管理：连接器验证权限，分配线程处理请求</li><li>解析优化：解析器生成语法树，优化器选择执行计划（索引的使用）</li></ul><h2 id="事务和锁"><a href="#事务和锁" class="headerlink" title="事务和锁"></a>事务和锁</h2><ul><li>隐式&#x2F;显式事务：InnoDB 默认自动开始事务（autocommit&#x3D;1)</li><li>加锁：根据隔离级别对目标行加锁</li></ul><h2 id="Undo-Log记录"><a href="#Undo-Log记录" class="headerlink" title="Undo Log记录"></a>Undo Log记录</h2><ul><li>写入回滚段：生成Undo Log记录插入行的主键信息（用于回滚或MVCC）</li><li>Redo保护Undo：Undo Log的修改会被记录到Redo Log（确保崩溃可恢复）</li></ul><h2 id="内存操作（Buffer-Pool）"><a href="#内存操作（Buffer-Pool）" class="headerlink" title="内存操作（Buffer Pool）"></a>内存操作（Buffer Pool）</h2><ul><li>定位数据页<ul><li>检查目标页是否在Buffer Pool中</li><li>不在，从磁盘中读取到Buffer Pool（触发淘汰）</li></ul></li><li>插入数据：修改内存中的数据页，标记为脏页</li><li>Change Buffer优化：若涉及非唯一二级索引，延迟索引更新</li></ul><h2 id="Redo-Log写入"><a href="#Redo-Log写入" class="headerlink" title="Redo Log写入"></a>Redo Log写入</h2><ul><li>生成物理日志：记录数据页变更（页号，偏移量，新数据）</li><li>写入Log Buffer：日志暂存缓冲区</li><li>刷盘策略：事务提交根据 <code>innodb_flush_log_at_trx_commit</code>决定是否刷盘</li></ul><h2 id="BinLog写入"><a href="#BinLog写入" class="headerlink" title="BinLog写入"></a>BinLog写入</h2><ul><li>生成逻辑日志：根据<code>binlog_format</code>记录SQL语句或行变更</li><li>两阶段提交<ul><li>Prepare：Redo Log标记为 prepare</li><li>Write &amp; Sync BinLog：BinLog写入并刷盘（依赖 <code>sync_binlog</code>）</li><li>Commit阶段：Redo Log标记事务为Commit；</li></ul></li></ul><h2 id="事务提交确认"><a href="#事务提交确认" class="headerlink" title="事务提交确认"></a>事务提交确认</h2><ul><li>客户端响应：返回结果，事务逻辑完成</li><li>释放锁：释放行锁（受MVCC影响，延迟清理UndoLog）</li></ul><h2 id="脏页刷新（异步）"><a href="#脏页刷新（异步）" class="headerlink" title="脏页刷新（异步）"></a>脏页刷新（异步）</h2><ul><li>触发条件<ul><li>Buffer Pool 空间不足</li><li>Redo Log写满触发 checkPoint</li><li>后台线程周期刷新</li></ul></li><li>刷盘过程<ul><li>通过 DoubleWrite Buffer 确保页写入原子性</li><li>脏页写入表空间（.ibd）</li><li>更新Buffer Pool页状态</li></ul></li></ul><h2 id="日志清理和复用"><a href="#日志清理和复用" class="headerlink" title="日志清理和复用"></a>日志清理和复用</h2><ul><li>Redo Log循环使用：Checkpoint后，旧Redo Log可覆盖。</li><li>Undo Log回收：无活跃读视图后，释放Undo空间。</li></ul><h1 id="日志协作关系"><a href="#日志协作关系" class="headerlink" title="日志协作关系"></a>日志协作关系</h1><table><thead><tr><th>日志类型</th><th>写入时机</th><th>核心作用</th><th>持久化依赖</th></tr></thead><tbody><tr><td>UndoLog</td><td>数据修改前</td><td>回滚事务，MVCC读视图</td><td>依赖Redo Log保护</td></tr><tr><td>RedoLog</td><td>数据修改后，事务提交前</td><td>崩溃恢复脏页数据</td><td><code>innodb_flush_log_at_trx_commit</code></td></tr><tr><td>BinLog</td><td>事务提交前（两阶段提交）</td><td>主从复制，时间点恢复</td><td><code>sync_binlog</code></td></tr></tbody></table><h2 id="崩溃恢复流程"><a href="#崩溃恢复流程" class="headerlink" title="崩溃恢复流程"></a>崩溃恢复流程</h2><ol><li>Redo Log前滚：从Checkpoint重放所有未刷盘的Redo Log，恢复脏页。</li><li>Undo回滚：对未提交的事务（Redo状态为PREPARE但无对应Binlog），用Undo Log回滚</li><li>Binlog校验：确保Redo Log和Binlog一致性（XA事务恢复）</li></ol><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>WAL机制（Write ahead Log）：日志现行，确保数据安全</li><li>内存优先：Buffer Pool机制</li><li>多日志协同：Redo Log保证物理恢复，Undo Log支持事务逻辑，BinLog实现生态扩展</li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>insert</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL存储引擎</title>
    <link href="/2025/04/10/mysql/engine/"/>
    <url>/2025/04/10/mysql/engine/</url>
    
    <content type="html"><![CDATA[<h2 id="常见存储引擎"><a href="#常见存储引擎" class="headerlink" title="常见存储引擎"></a>常见存储引擎</h2><ul><li>InnoDB：提供了事务安全的存储引擎，支持外键约束，行级锁定和崩溃恢复的能力；提供高可用和可靠性</li><li>MyISAM：提供了较快的查询性能，不支持事务和外键约束；适合读密集型应用，比InnoDB更快</li><li>Memory：将数据存储在内存中，适合临时数据存储和高速访问，Hash索引</li><li>Archive：存储归档数据，不支持更新和删除操作，避免大量查询</li></ul><h2 id="存储引擎比较"><a href="#存储引擎比较" class="headerlink" title="存储引擎比较"></a>存储引擎比较</h2><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th><th>ARCHIVE</th></tr></thead><tbody><tr><td>事务支持</td><td>✅ (ACID兼容)</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>锁粒度</td><td>行级锁</td><td>表级锁</td><td>表级锁</td><td>仅支持并发插入（无行锁）</td></tr><tr><td>外键约束</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>崩溃恢复</td><td>✅ (redo日志)</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>索引类型</td><td>B+树聚簇索引</td><td>B+树非聚簇<br>(数据和索引分离)</td><td>Hash(默认)&#x2F;Heap</td><td>压缩存储</td></tr><tr><td>缓存机制</td><td>缓冲池管理</td><td>仅缓存索引</td><td>内存存储</td><td>无读缓存机制,压缩写入</td></tr><tr><td>典型应用场景</td><td>OLTP事务处理</td><td>数据仓库</td><td>临时数据集</td><td>日志归档(写多读少)</td></tr></tbody></table><h2 id="InnoDB-介绍"><a href="#InnoDB-介绍" class="headerlink" title="InnoDB 介绍"></a>InnoDB 介绍</h2><p>特性：</p><h3 id="修改缓冲（change-buffer）"><a href="#修改缓冲（change-buffer）" class="headerlink" title="修改缓冲（change buffer）"></a>修改缓冲（change buffer）</h3><p>change buffer 可以提升插入，更新，删除操作的效率；默认占用 buffer pool的25%，最大50%;</p><ul><li>二级索引通常不是唯一的，并且插入二级索引的顺序相对随机，类似，删除和更新可能影响索引树中不相邻的二级索引页；<ul><li>当其他操作将受影响的页面读入缓冲池时，稍后合并缓存更改可以避免从磁盘将辅助索引页读如缓冲池所需的大量随机IO</li></ul></li><li>针对二级索引，且索引不包含主键索引</li><li>合并的频率<ul><li>辅助索引页被读取到缓冲池中，正常select先检查change buffer是否存在非聚集索引页存在，否则合并插入</li><li>辅助索引页没有可用空间，会强制合并操作</li></ul></li></ul><h3 id="二次写-double-write"><a href="#二次写-double-write" class="headerlink" title="二次写 (double write)"></a>二次写 (double write)</h3><p>双写缓冲区是一个存储区域，InnoDB 在将页面写入 InnoDB 数据文件中的正确位置之前先将页面写入从缓冲池刷新的位置。 </p><p>如果在页面写入过程中存在操作系统、存储子系统或意外的 mysqld 进程退出，InnoDB 可以在崩溃恢复期间从双写缓冲区中找到页面的良好副本</p><ul><li>虽然数据被写入两次，但双写缓冲区不需要两倍的 I&#x2F;O 开销或两倍的 I&#x2F;O 操作。 通过对操作系统的一次 fsync() 调用，将数据以大的顺序块写入双写缓冲区（innodb_flush_method 设置为 O_DIRECT_NO_FSYNC 的情况除外）。</li><li>存储在double write file 中</li></ul><h3 id="自适应哈希索引（ahi）"><a href="#自适应哈希索引（ahi）" class="headerlink" title="自适应哈希索引（ahi）"></a>自适应哈希索引（ahi）</h3><p>InnoDB对于某些频繁访问的索引值（二级索引），会在原有的B+Tree索引上，内存上构建了一个Hash索引，使得索引具有了一部分哈希索引的优势（快速查找）；</p><h3 id="预读（read-ahead）"><a href="#预读（read-ahead）" class="headerlink" title="预读（read ahead）"></a>预读（read ahead）</h3><p>InnoDB维护一个缓冲池的存储区域，用户与在内存中缓存数据和索引，利用它将经常访问的数据保存在内存中，是MYSQL调优的一个重要方面；</p><p>预读是当发起一个IO请求时，它异步预取缓冲池的多个页面。innodb 64个page为一个extent，按page或extent为预读单位区分两种预读算法 <strong>线性预读和随机预读</strong>；</p><ul><li>线性预读<ul><li>根据缓存池中按照顺序访问的页面来预测可能很快需要哪些页面</li><li>触发时机根据参数 <code>innodb_read_ahead_threshold</code> 控制，默认56；<ul><li>当一个extent被顺序读取的页大于等于这个值，就把下一个extent读取到buffer pool中，异步执行；</li><li>没有设置该值，会在读取当前extent最后一页时计算是否对整个next extent发出异步预取请求</li></ul></li></ul></li><li>随机预读：page为单位<ul><li>当同一个 extent 中的一些page在 buffer pool中发现时，innodb将会该extent中剩余page一并读到buffer pool中；</li><li>因为随机预读方式给innodb cache带来了不必要的复杂性，同时性能存在不稳定性，5.5及后续版本将这种预读方式废弃，默认OFF；<ul><li>启用，将配置变量 <code>innodb_random_read_ahead</code> 为ON</li></ul></li></ul></li></ul><h2 id="InnoDB-存储结构"><a href="#InnoDB-存储结构" class="headerlink" title="InnoDB 存储结构"></a>InnoDB 存储结构</h2><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul><li>页（page）：InnoDB 将物理磁盘划分为页（page），每页的大小默认16KB，页是最小的存储单位，页根据上层应用的需要，如索引，日志等；<ul><li>主要是索引页和数据页</li></ul></li><li>区（Extent）：因为需要维护很多页的状态，管理成本过高；引用区的概念，一个区由64个页组成，1MB，通过Extent对于存储空间进行分配和回收；</li><li>段（Segment）：表空间内的逻辑存储单元，用于管理数据页的分配和组织<ul><li>段用于逻辑划分表中不同用途的数据页<ul><li>数据段-&gt;存储数据页</li><li>索引段-&gt;存储二级索引页</li><li>Undo段-&gt;存储Undo页</li></ul></li></ul></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">表空间└── Segment    └── Extent (64 pages)        └── Page (16KB)            ├── File Header            ├── Page Header            ├── Infimum/Supremum Records            ├── User Records            └── Page Directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="页的组成部分"><a href="#页的组成部分" class="headerlink" title="页的组成部分"></a>页的组成部分</h3><p><img src="/image/mysql/innodb-page.png"></p><ul><li><strong>file header</strong>: <ul><li>数据页的外部信息，表空间，<strong>前后的页号</strong></li></ul></li><li><strong>page header</strong>：<ul><li>描述数据页的具体信息，记录数量，记录位置</li></ul></li><li><strong>infimum+superemum</strong>：<ul><li>系统生成记录，记录最小和最大的记录数量；</li><li>infimum的下一条是用户记录中间值最小的记录，superemum的上一条是用户记录中键值最小的记录，<strong>通过next_record字段相连</strong></li></ul></li><li><strong>user records</strong>:<ul><li>用户数据，记录数据表中的对应数据，常用 compact 格式</li><li>除了插入数据外，还有一些隐藏列<ul><li>transaction_id：事务ID</li><li>roll_pointer：回滚指针（undo log）</li><li>row_id(没有主键)：主键ID<br><img src="/image/mysql/innodb-page-user-records-compact.png"></li></ul></li></ul></li><li><strong>free space</strong>：<ul><li>页中目前空闲的存储，可以插入记录</li></ul></li><li><strong>page dictionary</strong>：<ul><li>字段目录，根据主键的大小，每隔 4-8 个纪录设置一个槽，用来纪录其位置，当根据主键查找数据时，首先一步到位找到数据所在的槽，然后在槽中线性搜素。</li><li>这种方法比从前到后遍历页的链表的效率更快。</li></ul></li><li><strong>page tailer</strong>：<ul><li>file header 存储刷盘前内存的校验和，page tailer存储刷盘后的校验和，当刷盘时出现异常，Page Tailer和File Header中的校验和不一致，则说明出现刷盘错误</li><li>工作流程<ul><li>页修改阶段（内存）<ul><li>页在buffer pool中被修改</li><li>计算修改后的checkSum 和 LSN（log sequence number)</li><li>写入page tailer总</li></ul></li><li>页刷新到磁盘中（包含page tailer）</li><li>页从磁盘中读入buffer pool<ul><li>重新计算当前页的 checksum</li><li>比较计算出的checksum和页中page tailer存储的checksum</li><li>不一致，页已损坏，触发校验错误</li></ul></li></ul></li></ul></li></ul><h3 id="InnoDB中插入数据的过程"><a href="#InnoDB中插入数据的过程" class="headerlink" title="InnoDB中插入数据的过程"></a>InnoDB中插入数据的过程</h3><ol><li>FreeSpace中空间足够，直接分配空间添加记录，并将插入前最后一条记录的 next_record 指向当前插入的记录，将当前插入记录的next_record指向superemum记录；</li><li>如果 FreeSpace空间不足的话，首先将之前删除造成的碎片重新整理，按照上述步骤插入数据</li><li>如果 整理后仍然不足的话，则重新生成一个页，将页初始化后，按照上述步骤插入记录</li></ol><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>这里着重介绍了InnoDB引擎特性，后续介绍InnoDB的架构和底层线程作用；</p><p>Buffer Pool 是 InnoDB 存储引擎层的缓冲池，不属于 MySQL 的 Server 层；</p><p>内存中以页（page）为单位缓存磁盘数据，减少磁盘IO，提升访问速度。缓冲池大小默认 128M，独立的 MySQL 服务器推荐设置缓冲池大小为总内存的 80%。主要存储数据页、索引页更新缓冲（change buffer）等</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>engine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务</title>
    <link href="/2025/04/01/mysql/transaction/"/>
    <url>/2025/04/01/mysql/transaction/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h2 id="什么是数据库事务"><a href="#什么是数据库事务" class="headerlink" title="什么是数据库事务"></a>什么是数据库事务</h2><p>数据库事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态；事务是逻辑上的一组操作，要不都执行，要不都不执行；</p><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><blockquote><ul><li><strong>atomicity</strong> 原子性:<br><br>事务是最小的执行单位，不允许分割；事务的原子性确保动作要么全部完成，要不不起作用；</li><li><strong>consistency</strong> 一致性：<br><br>事务执行前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；从一个一致性状态到另一个一致性状态；</li><li><strong>islation</strong> 隔离型：<br><br>并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的</li><li><strong>durability</strong> 持久性<br><br>一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</li></ul></blockquote><h2 id="事务的隔离级别（对应可能出现的问题）"><a href="#事务的隔离级别（对应可能出现的问题）" class="headerlink" title="事务的隔离级别（对应可能出现的问题）"></a>事务的隔离级别（对应可能出现的问题）</h2><table><thead><tr><th>隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td>读未提交</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td>读已提交</td><td align="center">X</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td>可重复读</td><td align="center">X</td><td align="center">X</td><td align="center">Y</td></tr><tr><td>可串行化</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr></tbody></table><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><h4 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h4><blockquote><p>一个事务开启了些事务，其他事务不允许同时进行写操作，但是允许其他事务的读操作；</p><p>通过排他写锁实现，避免了更新丢失，但是当事务回滚时，可能出现脏读，其他事务可能读取未提交数据；</p></blockquote><h4 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h4><blockquote><p>一个读事务，允许其他线程读写，写事务，禁止其他事务访问该数据，避免了脏读，可能出现不可重复；</p><p>A读，B更新，A再读；</p></blockquote><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><blockquote><p>一个事务内，多次读取同一个数据，事务未结束时，其他事务不能访问数据（包括读写），保证读取的数据是一致的；</p><p>读取事务，禁止写事务；写事务，禁止其他事务；通过共享读锁&#x2F;排他写锁实现，可能出现幻读；</p><blockquote><p>快照读（select）：通过 MVCC 方式解决幻读</p><p>MVCC<strong>不能完全避免幻读现象</strong>，因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录<strong>条目就不一样了</strong>，所以就发生幻读</p><p>当前读（select … for update）：通过 next-key lock（记录锁+间隙锁）方式解决了幻读；</p><p>如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务<strong>后续使用当前读进行查询的时候</strong>，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</p></blockquote></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 建表语句CREATE TABLE test (          name NVARCHAR(50),          age INT,          score DECIMAL(5,2));INSERT INTO test (name, age, score) VALUES(&#39;Alice&#39;, 20, 88.5),(&#39;Bob&#39;, 22, 76.0),(&#39;Charlie&#39;, 21, 91.2),(&#39;David&#39;, 23, 69.4),(&#39;Eve&#39;, 20, 85.0),(&#39;Frank&#39;, 24, 72.3),(&#39;Grace&#39;, 22, 95.6),(&#39;Heidi&#39;, 21, 64.8),(&#39;Ivan&#39;, 23, 79.1),(&#39;Judy&#39;, 20, 90.0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 快照读的case-- 事务 ASTART TRANSACTION;SELECT * FROM test WHERE score &gt; 90;-- 事务 B（并发）START TRANSACTION;INSERT INTO test (name, age, score) VALUES (&#39;Zoe&#39;, 22, 95.0);COMMIT;-- 事务 A（继续）UPDATE test SET age &#x3D; 23 WHERE name &#x3D; &#39;Zoe&#39;;  -- 现在A看到了这条记录SELECT * FROM test WHERE score &gt; 90;          -- 出现幻读<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 当前读的case-- 事务 ASTART TRANSACTION;SELECT * FROM test WHERE score &gt; 90;-- 事务 B-- 事务 B（并发）START TRANSACTION;INSERT INTO test (name, age, score) VALUES (&#39;Zoe&#39;, 22, 95.0);COMMIT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h4><blockquote><p>会对记录加上读共享锁（范围读意向共享锁），在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</p></blockquote><h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><blockquote><ul><li>脏读：<br>  <br> 一个事务读取到另一个未提交事务的数据；未提交事务回滚时后，读取的数据就是脏数据（读未提交时出现）</br></li><li>不可重复读：<br>  <br>一个事务两次读取的数据不一致，事务之间穿插其他事务对于记录的更新（读未提交&#x2F;读已提交出现）</br></li><li>幻读：<br>  <br>一个事务中两次读取的<strong>数据量不一致</strong>（读未提交&#x2F;读已提交&#x2F;可重复读出现）</br></li></ul></blockquote><h2 id="ACID特性的实现"><a href="#ACID特性的实现" class="headerlink" title="ACID特性的实现"></a>ACID特性的实现</h2><h3 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h3><ul><li>undo log（事务日志）保证</li><li>关键事务回滚，通过 undo log实现，数据库修改时，innodb 会生成对应的undo log；</li><li>事务执行失败，或者rollback时，利用 undo log将数据回滚</li><li>undo log属于逻辑日志，记录sql执行的相关信息</li></ul><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><ul><li>redo log（事务日志）保证</li><li>redo log 用来解决 crash safe 的问题，数据修改时，处理修改buffer pool中的数据，还会在redo log记录这次操作<ul><li>redo log 记录的是具体的行数据的修改，不是具体的语句</li></ul></li><li>事务提交时，会使用 fsync 对于 redo log 进行刷盘</li><li>redo log 采用 WAL（write-ahead logging，预写式日志），所有修改先写入日志，再更新 buffer pool，保证数据不会因为mysql宕机丢失，满足了持久性要求</li><li>redo log 更快的原因：1.顺序IO 2.只需要包含变更部分，不需要按页刷新</li><li>提高数据库的IO效率，引入了buffer pool， 但是buffer pool会带来了特殊情况（宕机等），buffer pool的数据没有刷新到磁盘中（刷脏），就会造成数据丢失，无法保证数据的持久性；</li></ul><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><ul><li>并发情况下互不干扰</li><li>写操作对于写操作的影响，锁机制保证</li><li>写操作对于读操作的影响，MVCC保证</li></ul><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><ul><li>数据库的完整性约束没有被破坏，事务执行前后都是合法的数据状态，需要数据库和应用层的共同保证</li><li>保证原子性，持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li><li>应用层保证</li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>水塘抽样</title>
    <link href="/2024/04/21/algorithm/pondSample/"/>
    <url>/2024/04/21/algorithm/pondSample/</url>
    
    <content type="html"><![CDATA[<p>水塘抽样算法 n个数字中 等概率 取 m 个数字</p><p>时间复杂度 O(n) 空间复杂度 O(1)</p><p>基础规则：</p><ul><li>先对于 前m个进行抽样，放入水塘中</li><li>对于第 j 项（j&gt;m)，以 m&#x2F;j 的概率替换掉一个随机样本</li><li>如果 第 j 项 被选中，那么水塘中随机选出一个样本并用 第 j 项 替换；</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ReservoirSampling</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> m <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建随机数种子，避免每次生成相同的随机数</span>    rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 初始化水塘，放入前m个元素</span>    reservoir <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        reservoir<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i    <span class="token punctuation">&#125;</span>    <span class="token comment">// 等概率的对剩余元素进行抽样</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> m<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 生成一个[0, i]之间的随机数</span>        r <span class="token operator">:=</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// 如果随机数在[0, m-1]之间，用当前元素替换水塘中的对应元素</span>        <span class="token keyword">if</span> r <span class="token operator">&lt;</span> m <span class="token punctuation">&#123;</span>            reservoir<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> reservoir<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脏页刷新</title>
    <link href="/2024/04/04/mysql/cacheSync/"/>
    <url>/2024/04/04/mysql/cacheSync/</url>
    
    <content type="html"><![CDATA[<h1 id="INNODB-刷脏页"><a href="#INNODB-刷脏页" class="headerlink" title="INNODB 刷脏页"></a>INNODB 刷脏页</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>为了提高mysql的性能和吞吐量，使用内存 buffer pool，缓存磁盘页数据，减少磁盘IO；但是需要将buffer pool中的脏页刷新入磁盘中，保证数据的一致性；</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>脏页：内存数据页和磁盘数据页数据不一致时，称内存页为脏页<br>LSN：日志的逻辑序号（log sequence number），innodb中lsn占用8个字节；LSN 的值随着日志的写入而逐渐增大；事务更新操作会产生一个新的LSN；LSN不仅存在于redo log中，还存在于数据页中；</p><h2 id="Redo-log-和内存数据"><a href="#Redo-log-和内存数据" class="headerlink" title="Redo log 和内存数据"></a>Redo log 和内存数据</h2><p><strong>内存中的数据和 redo log是一致的</strong>；redo log的作用就是为了保证数据一致性；crash-safty</p><h2 id="如何判断脏页呢？"><a href="#如何判断脏页呢？" class="headerlink" title="如何判断脏页呢？"></a>如何判断脏页呢？</h2><ol><li>redo log记录了 LSN（Log Sequence Number）</li><li>redo log的check point 位于某个LSN，说明LSN之前的数据已经被刷入磁盘中了；</li><li>内存中 干净页 如果有修改，修改后该页的LSN 大于checkpoint 的LSN，则在写 redo log 的同时该页也会被脏页记录到脏页列表中</li></ol><h2 id="刷脏页的时机："><a href="#刷脏页的时机：" class="headerlink" title="刷脏页的时机："></a>刷脏页的时机：</h2><ol><li>redo log满了<br>停止更新操作，把checkpoint 往前推，为了能有足够的 redo log 留有空间可以继续写，移动范围内日志，将对应的脏页都 flush 到磁盘中；</li><li>需要新的内存页，buffer pool不够用了淘汰<br>淘汰部分内存页，空出内存给别的使用，如果淘汰的是脏页，就先讲脏页刷新到磁盘上；</li><li>认为系统空闲时，逐步刷新</li><li>正常关闭，会先刷新所有的脏页</li></ol><h2 id="刷脏页影响"><a href="#刷脏页影响" class="headerlink" title="刷脏页影响"></a>刷脏页影响</h2><p>正常关闭和系统空闲时，没有什么影响</p><p>redo log 满了，一旦发生，所有的更新操作就会停止 – redo log 大小需要合理设置</p><p>内存页的三种状态： 未使用，干净页，脏页；<br>当读入数据页时，需要到buffer pool中申请一个数据页；淘汰的是最久不使用的页；当淘汰的为被标记的脏页，就需要将脏页刷新到磁盘中，再复用；– 控制脏页的比例</p><h2 id="控制刷脏页"><a href="#控制刷脏页" class="headerlink" title="控制刷脏页"></a>控制刷脏页</h2><ul><li><code>innodb_io_capacity</code>：写入磁盘的能力，根据这个值，确定刷脏页的速度；占用部分的能力，避免影响正常请求；</li><li><code>innodb_max_dirty_pages_pct</code>：最大脏页比例，更具当前的脏页比例和redo log剩余空间，计算刷盘的百分比R，从而计算出刷脏页速度&#x3D;innodb_io_capacity*R%</li></ul><p>为了防止刷脏影响性能，合理设置 redo log buffer的大小，innodb_io_capacity，innodb_max_dirty_pages_pct;</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>当用户写入（插入，删除，更新）请求执行时，会对buffer pool中的 Page 修改，被修改的Page称为 脏页<br>脏页被统一管理在 buffer pool 中的 Flush List 链表中，同时也被挂载在 LRU list中，脏页 一定在 Flush List 和 LRU List中；<br>有一组 <strong>Page Cleaner</strong> 线程周期对Flush List 上的 脏页进行刷新，称为刷脏；<br>只有完成数据页的持久化，才能推进整个 BP 的 Flush LSN，从而推进 Checkpoint LSN，保证 Checkpoint 之前的Redo log 尽快的回收；<br>Checkpoint LSN的及时推进能够帮助数据库出现意外的crash时，在Recovery阶段减少需要回放的Redo，加快节点的重启速率，减少宕机带来的影响；</p><h3 id="Page-Cleaner-线程组"><a href="#Page-Cleaner-线程组" class="headerlink" title="Page Cleaner 线程组"></a>Page Cleaner 线程组</h3><p>Page Cleaner线程是Innodb中持久化Page的一组线程，除了Redo以外的数据持久化工作全部由Page Cleaner线程完成，包括用户表，系统表，Undo，DD等所有表的Page。</p><p>Page Cleaner线程使用了Innodb中经典的一个Coordinator和多个Worker的线程组设计，其中Coordinator负责对任务的切分和调度，Worker负责实际的工作内容，当然在分配完任务后Coordinator也会作为其中的一个Worker完成自己的那部分工作。</p><p>在Page Cleaner Coordinator中，会判断是否要执行刷脏，以及自适应计算每次刷脏需要刷的Page数量等操作，而Worker线程只需要将自己获取到的BP instance按照所设定的n_pages进行刷盘，默认Woker线程的数量和Buffer Pool Instances数量相当。</p><p>在Page Cleaner Coordinator线程<strong>默认每间隔1秒触发一次刷脏操作</strong>，刷完就会Sleep，除非有其他Checkpoint等操作触发<strong>Sync Flush</strong>，也就是同步刷脏，Sync Flush会将BP的Flush lsn推进到指定的buf_flush_sync_lsn。</p><h3 id="同步刷脏"><a href="#同步刷脏" class="headerlink" title="同步刷脏"></a>同步刷脏</h3><p>除了默认的Coordinator按照固定频率刷脏外，Innodb还存在强制触发刷脏的机制，这些操作统一被称为同步刷脏，即必须要把当前Buffer Pool的flush lsn推进至某一个固定位点。</p><p>同步刷脏通常会设置一个<code>buf_flush_sync_lsn</code>，当Coordinator线程在运行过程中发现buf_flush_sync_lsn不为0，则会触发同步刷脏（即全量刷脏），把所有Oldest modification lsn小于buf_flush_sync_lsn位点的Dirty Page全部进行刷脏落盘，同步刷脏时，要刷的Page数量是<strong>不受innodb_io_capacity限制</strong>，同步刷脏会抢占大量的IO资源，同时在每个Page刷脏落盘的IO过程中也会持有该Page的SX锁，这些操作会影响用户的写入请求，可能会出现性能抖动。</p><h3 id="自定义刷脏"><a href="#自定义刷脏" class="headerlink" title="自定义刷脏"></a>自定义刷脏</h3><p>Page Cleaner每次刷脏的Page数量是通过一个自适应算法来实现的，代码逻辑主要集中在page_cleaner_flush_pages_recommendation()函数中，这个自适应刷脏算法是按照一个固定频率srv_flushing_avg_loops（默认30秒）来调整的，每次调整的数值主要依赖以下几个条件：</p><ul><li>Redo平均产生速率及其产生的平均脏页数量</li><li>平均每秒的刷脏数量</li><li>IO Capacity参数以及实际脏页率</li></ul><p>Redo平均产生速率及其产生的平均脏页数量的计算规则比较简单，即计算每个间隔之间的平均Redo lsn 产生速率，计算出一个Tagert lsn，然后依据Tagert lsn去查找在BP的Flush list上所有oldest_modification_lsn小于Tagert lsn的Page数量，以此来估算出Redo所产生的平均脏页数量；</p><p><a href="http://mysql.taobao.org/monthly/2023/04/02/">内核月报（刷脏优化）</a></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>protobuffer</title>
    <link href="/2024/03/01/protobuffer/"/>
    <url>/2024/03/01/protobuffer/</url>
    
    <content type="html"><![CDATA[<p>protocol buffers （ProtoBuf）是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul><li>更小的数据量：二进制编码，类型优化，编码比json和xml小的多；在网络传输和存储上有较大优势；</li><li>更快的序列化和反序列化：二进制格式</li><li>跨语言：类似JSON的的跨语言，更收欢迎</li><li>易于扩展维护：利用 .proto 文件定义数据模型和格式，更加容易维护，并且版本兼容；</li><li>支持自定义插件，代码生成，提升开发效率；</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>可读性差：二进制编码，debug时比较麻烦；</li><li>部分语言官方还是不支持</li></ul><h1 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h1><p>protobuf高效的秘密在于它的编码格式，<br>它采用了 <strong>TLV(tag-length-value)</strong> 编码格式。每个字段都有唯一的 tag 值，它是字段的唯一标识。<br>length 表示 value 数据的长度，length 不是必须的，对于固定长度的 value，是没有 length 的。value 是数据本身的内容。</p><p><code>&lt;tag&gt; &lt;length(可选))&gt; &lt;val&gt;&lt;tag&gt; &lt;length(可选))&gt; &lt;val&gt;&lt;tag&gt; &lt;length(可选))&gt; &lt;val&gt;</code></p><p><strong>tag值，由 field_number和wire_type组成</strong>；field_number变长；wire_type暂时3个bit；</p><table><thead><tr><th align="center">wire_type</th><th align="center">used for</th><th align="center">meaning</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">int32,int64,uint32,uint64,sint32,sint64,bool,enum</td><td align="center">Varint+ZigZag</td></tr><tr><td align="center">1</td><td align="center">fixed64,sfixed64,double</td><td align="center">64-bit</td></tr><tr><td align="center">2</td><td align="center">string,bytes, embedded messages,repeated fields</td><td align="center">length-delimited</td></tr><tr><td align="center">5</td><td align="center">fixed32,sfixed32,float</td><td align="center">32bit</td></tr></tbody></table><p>Varint编码不需要字节长度length，退化为TV，64bit，32bit也不需要length</p><h2 id="Varint编码"><a href="#Varint编码" class="headerlink" title="Varint编码"></a>Varint编码</h2><ul><li>Base128 Varints 底层二进制存储，利用每个字节的MSB位（第一位）标记是否为结束符号位；低七位为存储数值的位</li><li>使用小端字节序；</li><li>负数，采用 Varints 编码会恒定占用 10 个字节，原因在于负数的符号位为 1, 对于负数其从符号位开始的高位均为 1；负数以补码的形式存储，导致数值会很大；</li></ul><h2 id="ZigZag编码"><a href="#ZigZag编码" class="headerlink" title="ZigZag编码"></a>ZigZag编码</h2><ul><li>zigzag解决Varints在负数场景下失效的问题</li><li>大致思想是首先对负数做一次变换, 将其映射为一个正数, 变换以后便可以使用 Varints 编码进行压缩, 这里关键的一点在于变换的算法, 首先算法必须是可逆的, 即可以根据变换后的值计算出原始值, 否则就无法解码, 同时要求变换算法要尽可能简单, 以避免影响 Protobuf 编码、解码的速度, 我们假设 n 是一个 32 位类型的数字,<ul><li>计算方式<br><code> (n &lt;&lt; 1) ^ (n &gt;&gt; 31)</code></li></ul></li><li>本质上是将：符号位移到了最后一位，转换为正数存储；适合存储小整数，而不是大整数；</li></ul><p>具体使用：<br>Varint：int32, int64, uint32, uint64, bool, enum<br>ZigZag：sint32, sint64</p><p>带有fixed的都是定长的；</p>]]></content>
    
    
    <categories>
      
      <category>protobuffer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>protobuffer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>quick_sort_partition</title>
    <link href="/2024/03/01/algorithm/quick-sort-partition/"/>
    <url>/2024/03/01/algorithm/quick-sort-partition/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序的分区算法"><a href="#快速排序的分区算法" class="headerlink" title="快速排序的分区算法"></a>快速排序的分区算法</h1><h2 id="Lomuto-分区方案"><a href="#Lomuto-分区方案" class="headerlink" title="Lomuto 分区方案"></a>Lomuto 分区方案</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>选择数组最后一个元素作为基准值</li><li>维护一个 <code>storeIndex</code>, 使得 <code>storeIndex</code> 之前的元素都小于基准值，之后的元素都大于基准值</li><li>一次遍历数组，遇到比 pivot 小的元素时，将其交换到 storeIndex 位置，并递增 storeIndex。 </li><li>最后将 pivot 放到正确的位置（即 storeIndex 处）。</li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最坏情况：O(n^2)</li><li>最好情况：O(nlogn)</li><li>平均情况：O(nlogn)</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">partitionLomuto</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>pivot <span class="token operator">:=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token comment">// 选择最后一个元素作为 pivot</span>storeIndex <span class="token operator">:=</span> left   <span class="token comment">// 维护一个边界，使其左侧小于 pivot</span><span class="token keyword">for</span> i <span class="token operator">:=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot <span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>storeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>storeIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>storeIndex<span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 把 pivot 放到最终位置</span>nums<span class="token punctuation">[</span>storeIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>storeIndex<span class="token punctuation">]</span><span class="token keyword">return</span> storeIndex <span class="token comment">// 返回 pivot 的最终位置</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：实现简单，代码量少</li><li>缺点：最坏情况下时间复杂度较高</li><li>适用场景：小规模数据排序</li><li>优化：随机选择 pivot，减少最坏情况的发生</li></ul><h2 id="Hoare-分区方案"><a href="#Hoare-分区方案" class="headerlink" title="Hoare 分区方案"></a>Hoare 分区方案</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>选择数组第一个元素作为基准值，可随机选择</li><li>使用两个指针 <code>left</code> 和 <code>right</code>，分别从数组两端向中间移动</li><li>当 <code>left</code> 指向的元素小于基准值，<code>left</code> 向右移动；当 <code>right</code> 指向的元素大于基准值，<code>right</code> 向左移动</li><li>当 <code>left</code> 和 <code>right</code> 都停止移动时，交换两个指针指向的元素</li><li>重复上述过程，直到 <code>left</code> 和 <code>right</code> 相遇</li></ul><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最坏情况：O(n^2)</li><li>最好情况：O(nlogn)</li><li>平均情况：O(nlogn)</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">partitionHoare</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>pivot <span class="token operator">:=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token comment">// 选择第一个元素作为 pivot</span>i<span class="token punctuation">,</span> j <span class="token operator">:=</span> left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token operator">+</span><span class="token number">1</span> <span class="token comment">// 设置指针边界</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token comment">// 向右找到第一个大于等于 pivot 的元素</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>i<span class="token operator">++</span><span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 向左找到第一个小于等于 pivot 的元素</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>j<span class="token operator">--</span><span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> i <span class="token operator">>=</span> j <span class="token punctuation">&#123;</span> <span class="token comment">// 当 i 和 j 交错时，返回分区点</span><span class="token keyword">return</span> j<span class="token punctuation">&#125;</span><span class="token comment">// 交换 nums[i] 和 nums[j]</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：最坏情况下的时间复杂度较好</li><li>缺点：实现较复杂</li><li>适用场景：大规模数据排序</li><li>优化：随机选择 pivot，减少最坏情况的发生</li></ul><h2 id="三向切分快速排序-Dutch-National-Flag-Partitioning"><a href="#三向切分快速排序-Dutch-National-Flag-Partitioning" class="headerlink" title="三向切分快速排序(Dutch National Flag Partitioning)"></a>三向切分快速排序(Dutch National Flag Partitioning)</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>选择数组第一个元素作为基准值，可随机选择</li><li>使用三个指针 <code>lt</code>, <code>i</code>, <code>gt</code>，分别指向小于、等于、大于基准值的元素</li><li>当 <code>i</code> 指向的元素小于基准值，交换 <code>lt</code> 和 <code>i</code> 指向的元素，<code>lt</code> 和 <code>i</code> 向右移动</li><li>当 <code>i</code> 指向的元素大于基准值，交换 <code>i</code> 和 <code>gt</code> 指向的元素，<code>gt</code> 向左移动</li><li>当 <code>i</code> 指向的元素等于基准值，<code>i</code> 向右移动</li><li>重复上述过程，直到 <code>i</code> 和 <code>gt</code> 相遇</li></ul><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最坏情况：O(n^2)</li><li>最好情况：O(nlogn)</li><li>平均情况：O(nlogn)</li></ul><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">partitionThreeWay</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pivot <span class="token operator">:=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token comment">// 选择最后一个元素作为 pivot</span>low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high <span class="token operator">:=</span> left<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token keyword">for</span> mid <span class="token operator">&lt;=</span> high <span class="token punctuation">&#123;</span><span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot <span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span>low<span class="token operator">++</span>mid<span class="token operator">++</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> pivot <span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span>high<span class="token operator">--</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>mid<span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> low<span class="token punctuation">,</span> high <span class="token comment">// 返回小于 pivot 和大于 pivot 的边界</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：适用于存在大量重复元素的数组</li><li>缺点：实现较复杂</li><li>适用场景：存在大量重复元素的数组</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><table><thead><tr><th>分区方法</th><th>使用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Lomuto</td><td>小规模数据排序</td><td>实现简单</td><td>最坏情况下时间复杂度较高</td></tr><tr><td>Hoare</td><td>大规模数据排序</td><td>最坏情况下时间复杂度较好</td><td>实现较复杂</td></tr><tr><td>三向切分</td><td>存在大量重复元素的数组</td><td>适用于存在大量重复元素的数组</td><td>实现较复杂</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rand</title>
    <link href="/2024/03/01/algorithm/rand/"/>
    <url>/2024/03/01/algorithm/rand/</url>
    
    <content type="html"><![CDATA[<h1 id="概率生成"><a href="#概率生成" class="headerlink" title="概率生成"></a>概率生成</h1><h2 id="Rand7-构造-Rand10"><a href="#Rand7-构造-Rand10" class="headerlink" title="Rand7 构造 Rand10"></a>Rand7 构造 Rand10</h2><h3 id="直接方式（拒绝采样）"><a href="#直接方式（拒绝采样）" class="headerlink" title="直接方式（拒绝采样）"></a>直接方式（拒绝采样）</h3><p>生成的随机数满足要求，返回该随机数，否则不断生成，直到生成一个满足要求的随机数为止；</p><p>利用 rand7() 相乘，只取得其中等概率的十个数字即可；</p><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">1234567</code></pre></div></figure><p>11234567<br>22468101214<br>336912151821<br>4481216202428<br>55101520253035<br>66121824303642<br>77142128354249</p><p>得到生成概率：选取10个等概率的数，其余的重新随机即可；</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">rand10</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">&#123;</span> row <span class="token operator">:=</span> <span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        col <span class="token operator">:=</span> <span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        idx <span class="token operator">:=</span> <span class="token punctuation">(</span>row<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">7</span> <span class="token operator">+</span> col        <span class="token keyword">if</span> idx <span class="token operator">&lt;=</span> <span class="token number">40</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>idx<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span>        <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h3><p>结合拒绝采样，分解rand10为 rand2 和 rand5;</p><p>当 rand2 为1 为 1-5， 为 2时， 6-10；</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">rand10</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  rand2<span class="token punctuation">,</span> rand5 <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>  <span class="token keyword">for</span> rand2 <span class="token operator">></span> <span class="token number">2</span> <span class="token punctuation">&#123;</span> rand2 <span class="token operator">=</span> <span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token comment">// 优化，为6</span>  <span class="token keyword">for</span> rand5 <span class="token operator">></span> <span class="token number">5</span> <span class="token punctuation">&#123;</span> rand5 <span class="token operator">=</span> <span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> rand2 <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">return</span> rand5  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> rand5<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>概率论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GC</title>
    <link href="/2024/03/01/golang/gc/"/>
    <url>/2024/03/01/golang/gc/</url>
    
    <content type="html"><![CDATA[<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p><code>Garbage Collection</code> 垃圾回收，自动内存管理的机制；当程序申请的内存不再被需要时，回收内存复用，获取还给操作系统；针对内存级别资源的自动回收过程，就是垃圾回收，负责垃圾回收的组件就是垃圾回收器；为什么需要垃圾回收，人力有限，避免内存泄露问题。牺牲一部分性能，提高程序的可用性，可靠性和稳定性；</p><p>垃圾回收器的执行过程被划分为两个独立的组件：</p><ul><li>赋值器（Mutator）：用户态代码，对于垃圾回收器来说，用户态代码只会修改，增加对象之间的引用关系；</li><li>回收器（Collector）：负责执行垃圾回收的代码；</li></ul><h2 id="根对象（根集合）"><a href="#根对象（根集合）" class="headerlink" title="根对象（根集合）"></a>根对象（根集合）</h2><p>指赋值器不需要通过其他对象就可以直接访问到的对象，通过Root对象, 可以追踪到其他存活的对象；</p><ul><li>全局变量：编译器就确定存在整个程序生命周期的变量；</li><li>执行栈：每个goroutine都有自己的执行栈，栈上包含栈变量和指向堆的指针；</li><li>寄存器：寄存器的值可能表示一个指针，参与计算的指针可能指向某些赋值器分配的堆内存区块；</li></ul><h1 id="常见的GC实现方式"><a href="#常见的GC实现方式" class="headerlink" title="常见的GC实现方式"></a>常见的GC实现方式</h1><h2 id="引用计数式GC"><a href="#引用计数式GC" class="headerlink" title="引用计数式GC"></a>引用计数式GC</h2><p>每个对象自身包含一个被引用的计数器，当计数器为0时自动得到回收，方法缺陷较多（循环引用），追求高性能通常不被使用，Python，OC等使用引用计数方式的GC；</p><p>实现简单，实时性强；</p><h2 id="追踪式GC"><a href="#追踪式GC" class="headerlink" title="追踪式GC"></a>追踪式GC</h2><p><code>核心：可达性即为可用性</code></p><p>一类基于”可达性”分析来进行内存回收的算法， 从根对象触发，通过追踪对象的引用关系，逐步找到所有能够被访问到的对象，这些对象被认为可存活，其他未被访问到的对象，被认为是垃圾，可回收；</p><h3 id="标记清除-mark-swap"><a href="#标记清除-mark-swap" class="headerlink" title="标记清除 mark-swap"></a>标记清除 mark-swap</h3><p>分为标记和清除两个阶段。标记阶段从根对象开始，将确定存活的对象进行标记；清除阶段遍历整个堆内存，回收未被标记的对象；会产生大量的内存碎片；</p><h3 id="标记压缩-mark-compact"><a href="#标记压缩-mark-compact" class="headerlink" title="标记压缩 mark-compact"></a>标记压缩 mark-compact</h3><p>和标记清除类似，但是清除部分不是直接清除未标记对象，而是将存活的对象压缩到内存的另一端，更新引用，再回收剩余的内存。避免了内存碎片，但是对于大对象的移动成本较高；</p><h3 id="分代收集-generational"><a href="#分代收集-generational" class="headerlink" title="分代收集 generational"></a>分代收集 generational</h3><p>根据对象的生命周期不同，将内存划分为新生代和老年代，可以针对不同代的特点采用最适合的算法，提高垃圾回收的效率。缺点就是管理复杂，需要合理划分不同代的大小以及不同代的晋升策略。</p><p>新创建的对象放入新生代，将经过一定次数GC（策略）仍然存活的新生代对象移动到老年代。</p><h3 id="复制-copying"><a href="#复制-copying" class="headerlink" title="复制 copying"></a>复制 copying</h3><p>将内存分为两块，新分配的对象放在其中一块内存中，当这块内存满了，就从根对象开始，复制所有可达的对象到另一块内存中，然后回收原来的内存区域。</p><p>避免了内存碎片，但是需要两倍的内存空间。主要适用于频繁分配和回收对象的场景，可以减少碎片的产生。</p><h3 id="增量和并发-incremental-concurrent"><a href="#增量和并发-incremental-concurrent" class="headerlink" title="增量和并发 incremental concurrent"></a>增量和并发 incremental concurrent</h3><p>对于上述的优化，目的是减少STW(stop the world)的时间，降低GC对于程序运行的影响；</p><p>增量垃圾回收是将垃圾回收的工作分解成多个小步骤，交错在程序运行中执行；并发垃圾回收则是让垃圾回收和程序运行在不同的线程中并发执行。</p><h1 id="Golang的垃圾回收算法"><a href="#Golang的垃圾回收算法" class="headerlink" title="Golang的垃圾回收算法"></a>Golang的垃圾回收算法</h1><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p><strong>三色标记法</strong>的关键是理解对象的<strong>三色抽象</strong>以及<strong>波面（wavefront）推进</strong>这两个概念。三色抽象只是一种描述追踪式回收器的方法，在实践中并没有实际含义，它的重要作用在于从逻辑上严密推导标记清理这种垃圾回收方法的正确性。也就是说，当我们谈及三色标记法时，通常指标记清扫的垃圾回收。</p><p><strong>三色抽象（将对象的状态抽象为三种状态）</strong></p><ul><li>白色对象（可能死亡）：未被回收器访问到的对象。回收开始阶段，所有对象都为白色，回收结束阶段，所有白色对象为不可达对象即垃圾；</li><li>灰色对象（波面）：已经被回收器访问到的对象，但回收器需要对于其中一个&#x2F;多个指针进行扫面，因为他们可能还指向存活的白色对象；</li><li>黑色对象（确认存活）：已经被回收器访问到的对象，其中的每个字段都已经被扫描，黑色对象中任何一个指针对象都不可能直接指向白色对象；</li></ul><p>三种不变性所定义的回收过程其实是一个<strong>波面</strong>不断前进的过程，这个波面同时也是黑色对象和白色对象的边界，灰色对象就是这个波面。</p><p><img src="/image/gc/three-color.png"></p><p>如果单纯执行三色标记法的GC，会出现因为标记过程中，对象引用变化导致的对象被错误的回收等各种问题。需要借助STW进行保证GC的正确执行；</p><p><strong>STW的过程有明显的资源浪费，对所有的用户程序都有很大影响；</strong></p><p>总结对象丢失，需要同时满足以下条件：</p><ul><li>白色对象被黑色对象引用</li><li>灰色对象和白色对象之间的可达关系被破坏</li></ul><h2 id="屏障机制"><a href="#屏障机制" class="headerlink" title="屏障机制"></a>屏障机制</h2><p>为了避免STW，需要破坏导致对象丢失的条件，引入两种限制条件分别针对上面丢失的情况：</p><ul><li>强三色不变式：<strong>黑色对象不能引用白色对象</strong>（不会存在白色对象被误删的情况）</li><li>弱三色不变式：<strong>所有被黑色对象引用的白色对象都处于灰色保护状态。</strong>（<strong>黑色对象可以引用白色对象，但是白色对象在可达的链路上游存在灰色对象</strong>）</li></ul><h2 id="插入写屏障（强三色不等式）：白色强制变为灰色"><a href="#插入写屏障（强三色不等式）：白色强制变为灰色" class="headerlink" title="插入写屏障（强三色不等式）：白色强制变为灰色"></a>插入写屏障（强三色不等式）：白色强制变为灰色</h2><p>不会存在黑色对象引用白色对象的情况；v1.5<br>插入写屏障仅会在堆内存中生效，不对栈空间生效，这是因为go在并发运行时，大部分的操作都发生在栈上，函数调用会非常频繁。数十万goroutine的栈操作都进行屏障保护自然会有性能问题。</p><p><strong>GC都是针对堆内存的活动</strong>，对象分布位置在栈和堆上，因为函数调用弹出的频繁使用，所以 <strong>插入屏障</strong> 机制，在栈空间的对象操作中不使用，只在<strong>堆空间对象</strong>的操作中；</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>保证标记算法和用户代码的并发执行</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>由于栈上的对像没有插入写机制，在扫描完成后，仍然可能存在栈的黑色对象，指向堆上的白色对象，所以在最后需要对栈上的空间进行STW，防止对象误删除。</p><p>在一次正常的三色标记流程结束后，需要对栈上重新进行一次stw，然后再rescan一次。</p><h2 id="删除写屏障（弱三色不等式）：-在删除引用时，如果被删除引用的对象自身为灰色或者白色，那么被标记为灰色。"><a href="#删除写屏障（弱三色不等式）：-在删除引用时，如果被删除引用的对象自身为灰色或者白色，那么被标记为灰色。" class="headerlink" title="删除写屏障（弱三色不等式）： 在删除引用时，如果被删除引用的对象自身为灰色或者白色，那么被标记为灰色。"></a>删除写屏障（弱三色不等式）： 在删除引用时，如果被删除引用的对象自身为灰色或者白色，那么被标记为灰色。</h2><p>白色对象始终会被保护，灰色对象到白色对象的路径不会断；v1.5</p><ol><li>删除写屏障也叫基于快照的写屏障方案，必须在起始时，STW 扫描整个栈（注意了，是所有的 goroutine 栈），保证<strong>所有堆上在用的对象</strong>都处于灰色保护下，保证的是弱三色不变式；</li><li>由于起始快照的原因，起始也是执行 STW，删除写屏障不适用于栈特别大的场景，栈越大，STW 扫描时间越长</li><li>删除写屏障会导致扫描进度（波面）的后退，所以扫描精度不如插入写屏障；</li></ol><p>如果不起始扫描所有栈，可能出现丢数据（栈上对象不触发屏障）</p><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>保护对象不丢失</p><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>一个对象的引用被删除后，即使没有其他存活的对象引用它，它仍然会活到下一轮。产生很多的冗余扫描成本，且降低了回收精度。</p><h2 id="混合写屏障：插入屏障和删除屏障进行混合，尽可能减少-STW-的时间。"><a href="#混合写屏障：插入屏障和删除屏障进行混合，尽可能减少-STW-的时间。" class="headerlink" title="混合写屏障：插入屏障和删除屏障进行混合，尽可能减少 STW 的时间。"></a>混合写屏障：插入屏障和删除屏障进行混合，尽可能减少 STW 的时间。</h2><p>核心定义：</p><ul><li>GC刚开始时，将栈上的<strong>所有可达对象</strong>标记为黑色</li><li>GC期间任何在栈上创建的对象都为黑色<ul><li>不需要对栈上的对象，stop the world，保证栈上的对象不会丢失</li></ul></li><li>堆上被删除的对象标记为灰色</li><li>堆上新增加的对象标记为灰色</li></ul><p>混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工作（针对一个 goroutine 栈来说，是暂停扫的，要么全灰，要么全黑哈，原子状态切换）；</p><h1 id="GC触发的情况"><a href="#GC触发的情况" class="headerlink" title="GC触发的情况"></a>GC触发的情况</h1><ul><li>内存分配量达到阈值触发GC<ul><li>当程序使用的内存超过一定阈值时，垃圾回收器会被触发以回收不再使用的内存空间。</li></ul></li><li>定期触发GC<ul><li>使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。</li></ul></li><li>手动触发GC<ul><li><code>runtime.GC()</code> 函数时，可以强制执行一次垃圾回收操作</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GMP模型</title>
    <link href="/2024/03/01/golang/gmp/"/>
    <url>/2024/03/01/golang/gmp/</url>
    
    <content type="html"><![CDATA[<h1 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h1><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>针对早期版本GM，并发1：1线程模型导致的问题</p><ul><li>调度器调度G时，全局锁竞争问题</li><li>M转移G会造成 <strong>延迟和额外的系统负载</strong> 。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了 <strong>很差的局部性</strong> ，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</li><li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。CPU切换线程，上下文开销，因为系统调用导致的线程频繁切换M；</li></ul><h2 id="GMP-的基本组成部份"><a href="#GMP-的基本组成部份" class="headerlink" title="GMP 的基本组成部份"></a>GMP 的基本组成部份</h2><h3 id="G-goroutine-协程"><a href="#G-goroutine-协程" class="headerlink" title="G: goroutine 协程"></a>G: goroutine 协程</h3><p>golang并发的执行单元</p><ul><li><strong>轻量性</strong>：每个goroutine都有自己的栈空间，定时器，初始化的栈空间2k（1.21），空间随着需求动态增长和压缩</li><li><strong>并发执行</strong>：通过关键字 <code>go</code> 可以方便的创建执行并发的goroutine；以非阻塞的方式执行任务，提高程序的吞吐量和性能</li><li><strong>调度</strong>：work-steal, hand-off 等机制保证性能释放</li><li><strong>同步</strong>：通过channel，sync等途径进行Goroutine之间的信息传递</li><li>对应的线程模型： M：N</li></ul><p>Goroutines 被多路复用到多个操作系统线程上，因此如果其中一个线程发生阻塞（例如在等待 I&#x2F;O 时），其他线程会继续运行。它们的设计隐藏了线程创建和管理的许多复杂性;</p><h3 id="M-machine-操作系统线程（应用层）"><a href="#M-machine-操作系统线程（应用层）" class="headerlink" title="M: machine 操作系统线程（应用层）"></a>M: machine 操作系统线程（应用层）</h3><p>实际的执行单元，M本身是应用层的概念，每个M绑定一个对应的内核线程。</p><h3 id="P-processor-管理调度的处理器"><a href="#P-processor-管理调度的处理器" class="headerlink" title="P: processor 管理调度的处理器"></a>P: processor 管理调度的处理器</h3><p>包含了运行Goroutine的资源，是和M关联的上下文，维护了一组Goroutine的队列，以及与之相关的调度器和执行堆栈。P 是用来管理调度 M 和执行 Goroutines 的实体。</p><ul><li>调度G：P 负责调度 Goroutines。它会从全局队列中获取 Goroutines 并将它们分配给 M 执行。</li><li>本地队列：<strong>：</strong> P 维护了一个本地队列，用于存放等待执行的 Goroutines。这种本地队列的设计可以提高调度的效率，避免过多的全局锁竞争。更好的运用局部性原理。</li><li>执行堆栈：P 包含了执行 Goroutines 所需的堆栈信息，它负责在执行过程中维护 Goroutine 的上下文信息。</li><li><strong>GOMAXPROCS</strong>：通过 GOMAXPROCS 环境变量或者 runtime.GOMAXPROCS() 函数可以控制 P 的数量。防止因为不合适的最大处理个数，导致的CPU利用率下降；</li></ul><h2 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程 线程 协程"></a>进程 线程 协程</h2><h3 id="进程-process"><a href="#进程-process" class="headerlink" title="进程 process"></a>进程 process</h3><p>运行时程序的封装，操作系统角度来看是操作系统对于进程的描述，linux <code>pcb </code>task_struct结构体；</p><ul><li><code>进程是操作系统资源分配和调度的基本单位</code>，实现了操作系统内部的并发；</li><li>每个进程都在独立的内存空间中（虚拟内存技术），互相之间不能访问对方的内存；</li><li>进程之间通常使用IPC（进程间通信）来交换数据</li></ul><p>具体进程内包含的东西，操作系统详述</p><h3 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程 thread"></a>线程 thread</h3><p>Linux下的线程是以进程pcb模拟实现的，并且这些pcb共用同一个虚拟地址空间，共享进程中的大部分资源，因此Linux下的线程实际上是一个 <code>轻量级进程</code>，相较传统进程更加 <code>轻量化</code>；</p><ul><li>线程是在进程内执行的 <code>独立执行单元</code>，多个线程可以共享同一进程的资源，包括内存空间和文件句柄等</li><li><code>线程是CPU调度的基本单位，CPU通过调度PCB实现程序调度</code></li><li>同一进程内的多个线程可以并发执行，共享同一地址空间，可以相互访问同一进程中的数据</li><li>由于共享资源，需要进行同步操作来避免多个线程之间的数据竞争</li></ul><h3 id="协程-coroutine"><a href="#协程-coroutine" class="headerlink" title="协程 coroutine"></a>协程 coroutine</h3><ul><li>协程是一种用户态的轻量级线程，它由程序员自行控制调度，而不是由操作系统控制。</li><li>协程可以在单线程中实现并发，可以根据需要在不同的时间点暂停、恢复、和切换执行。</li><li>由于协程是由用户控制调度的，因此切换开销比线程要小，可以有效提高程序的并发能力。</li></ul><h2 id="GMP调度模型"><a href="#GMP调度模型" class="headerlink" title="GMP调度模型"></a>GMP调度模型</h2><h3 id="调度器设计策略"><a href="#调度器设计策略" class="headerlink" title="调度器设计策略"></a>调度器设计策略</h3><p><strong>复用线程</strong>：避免频繁的创建，销毁线程，而是对线程的复用</p><ul><li>work steal 机制：当本线程无可运行的G时，全局队列中也不存在可用的G，尝试从其他M绑定的P中偷取G，而不是销毁线程</li><li>hand off 机制：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，将P转移给其他空闲的线程</li></ul><p><strong>利用并行</strong>：<code>GOMAXPROCS</code> 设置P的数量，最多有 <code>GOMAXPROCS</code>个线程分布在多个CPU上同时运行。<code>GOMAXPROCS</code>也限制了并发的程度；</p><p><strong>抢占</strong>：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在go中，一个goroutine最多占用一个线程10ms，防止其他线程被饿死，这就是goroutine和coroutine不同的地方</p><p><strong>全局G队列</strong>：新的调度器中仍然存在全局G队列，但是功能被弱化，当M无法执行work stealing从其他P偷不到G时，从全局G队列中获取G</p><h3 id="协程的调度流程"><a href="#协程的调度流程" class="headerlink" title="协程的调度流程"></a>协程的调度流程</h3><p><img src="/image/gmp/goroutine.png"></p><p><a href="https://www.kancloud.cn/aceld/golang/1958305">来源</a>  : Golang 修养之路</p><ol><li>通过go创建一个goroutine</li><li>有两个存储G的队列，一个是局部调度器P的本地队列(256大小)，一个是全局G队列。如果P的本地队列已经满了就会保存在全局队列中；</li><li>G只能运行在M中，一个M必须持有一个P，M和P时1：1关系。M会从P的本地队列弹出一个可执行状态的G来执行，P的本地队列为空，就会想从其他的P中偷取部分可执行的G</li><li>一个M调度G执行的过程是一个循环的过程</li><li>当M执行一个G发生了系统调用或者其他阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会将这线程M从P中摘除（detach），然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；</li><li>当M的系统调用结束时，这个G会尝试获取一个空闲的P执行，并放入这个P的本地队列。如果获取不到P，那么这个线程M就会变成休眠状态，加入到空闲线程队列中，这个G会被放入全局队列中；</li></ol><p>Note：</p><ul><li><p>应用内go出去的func()，如果P本地队列没有满的话，放入本地队列；</p></li><li><p>本地队列满创建新的goroutine，需要执行负载均衡(将P中前一半的队列打散，还有新创建的G转移到全局队列中)；</p></li><li><p>在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行 。提高cpu的利用率；唤醒的M没有可用的G时，进入自旋模式，这意味着它会轮询（自旋）查看全局队列中是否有可以执行的 Goroutine，而不是进入睡眠状态等待调度器唤醒。</p><ul><li>自旋模式的目的是避免线程阻塞和唤醒的开销，因为线程的阻塞和唤醒操作会涉及到操作系统的系统调用，其开销相对较大。通过自旋模式，M 可以在不进入睡眠状态的情况下等待新的任务。然而，自旋模式也会占用 CPU 资源，因此需要在平衡性能和资源利用的考量下使用。golang会根据系统负载，动态调整M的自旋行为；</li></ul></li><li><p>从全局Goroutine队列中获取可执行的Goroutine(<code>findrunnable()</code>)，获取的G个数；每次不会获取太多</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">n &#x3D;  min(len(GQ) &#x2F; GOMAXPROCS +  1,  cap(LQ) &#x2F; 2 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p>阻塞的系统调用：M1会和P1解绑，M1和对应的G进入系统调用，如果P1本地队列有G、全局队列有G或有空闲的M，P1都会立马唤醒1个M和它绑定，否则P1则会加入到空闲P列表，等待M来获取可用的p</p></li><li><p>非阻塞的系统调用：M1会和P1解绑，但是M1会标记P1，M1和对应的G进入系统调用状态，当M1退出系统调用时，会尝试获取P1，如果无法获取，则获取空闲的P，如果依然没有，G会被记为可运行状态，并加入到全局队列,M1因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)</p></li></ul><h3 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h3><pre><code class="mermaid">graph TD;A(开始) --> B(创建第一个线程M0);B --> C(创建第一个Go协程G0);C --> D(关联M0和G0);D --> E(调度初始化);E --> F("创建main()中的goroutine");F --> G(启动M0);G --> H(M绑定P);H --> I&#123;"M通过P获取到G?"&#125;;I --> |N|M(M休眠);M --> |"M被唤醒启动"|H;I --> |Y|J(M设置G环境);J --> K(M执行G);K --> L(G退出);L --> I;</code></pre><p>特殊的M0和G0</p><ul><li>M0<br>启动后编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要再heap上分配，m0负责执行初始化操作和启动第一个G，之后M0就和其他的M相同；</li><li>G0<br>每启动一个M都会第一个创建的goroutine，G0仅用于负责调度的G，G0不执行任何可执行的函数，每个M都会有一个自己的G0。在调度或系统调用是会使用G0的栈空间，全局变量的G0是M0的G0；</li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang map的底层结构和渐进式hash</title>
    <link href="/2024/03/01/golang/map/"/>
    <url>/2024/03/01/golang/map/</url>
    
    <content type="html"><![CDATA[<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>常用的数据结构，常用于去重和快速检索；不同的语言存在不同的实现</p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>map 底层实现红黑树， unordered_map 底层实现哈希表，使用链地址法处理哈希冲突</p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p>底层实现是hash表，分不同的hash bucket；</p><h3 id="hmap"><a href="#hmap" class="headerlink" title="hmap"></a>hmap</h3><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// A header for a Go map.</span><span class="token keyword">type</span> hmap <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.</span><span class="token comment">// Make sure this stays in sync with the compiler's definition.</span>count     <span class="token builtin">int</span> <span class="token comment">// # live cells == size of map.  Must be first (used by len() builtin)</span>flags     <span class="token builtin">uint8</span>B         <span class="token builtin">uint8</span>  <span class="token comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span>noverflow <span class="token builtin">uint16</span> <span class="token comment">// approximate number of overflow buckets; see incrnoverflow for details</span>hash0     <span class="token builtin">uint32</span> <span class="token comment">// hash seed</span>buckets    unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// array of 2^B Buckets. may be nil if count==0.</span>oldbuckets unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// previous bucket array of half the size, non-nil only when growing</span>nevacuate  <span class="token builtin">uintptr</span>        <span class="token comment">// progress counter for evacuation (buckets less than this have been evacuated)</span>extra <span class="token operator">*</span>mapextra <span class="token comment">// optional fields</span><span class="token punctuation">&#125;</span><span class="token comment">// mapextra holds fields that are not present on all maps.</span><span class="token keyword">type</span> mapextra <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// If both key and elem do not contain pointers and are inline, then we mark bucket</span><span class="token comment">// type as containing no pointers. This avoids scanning such maps.</span><span class="token comment">// However, bmap.overflow is a pointer. In order to keep overflow buckets</span><span class="token comment">// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.</span><span class="token comment">// overflow and oldoverflow are only used if key and elem do not contain pointers.</span><span class="token comment">// overflow contains overflow buckets for hmap.buckets.</span><span class="token comment">// oldoverflow contains overflow buckets for hmap.oldbuckets.</span><span class="token comment">// The indirection allows to store a pointer to the slice in hiter.</span>overflow    <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>bmapoldoverflow <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>bmap<span class="token comment">// nextOverflow holds a pointer to a free overflow bucket.</span>nextOverflow <span class="token operator">*</span>bmap<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>字段含义：</p><ul><li>count：元素数量</li><li>flags：标记竞态</li><li>B：2^B 存储 buckets 的数量</li><li>noverflow：存储 溢出桶的个数</li><li>hash0：哈希种子</li><li>buckets：hash bucket，bucket数组</li><li>oldbuckets：迁移时，记录扩容前的buckets</li><li>nevacuate：扩容进度，小于此地址的迁移已经完成；</li><li>extra：不一定有用，记录了overflow的bucket指针和下一个溢出的bucket指针; <strong>用于快速GC;</strong></li></ul><h3 id="bmap：bucket的底层结构"><a href="#bmap：bucket的底层结构" class="headerlink" title="bmap：bucket的底层结构"></a>bmap：bucket的底层结构</h3><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>MapBucketCountBits <span class="token operator">=</span> <span class="token number">3</span> <span class="token comment">// log2 of number of elements in a bucket.</span>MapBucketCount     <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> MapBucketCountBits<span class="token punctuation">)</span><span class="token comment">// A bucket for a Go map.</span><span class="token keyword">type</span> bmap <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// tophash generally contains the top byte of the hash value</span><span class="token comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span><span class="token comment">// tophash[0] is a bucket evacuation state instead.</span>tophash <span class="token punctuation">[</span>abi<span class="token punctuation">.</span>MapBucketCount<span class="token punctuation">]</span><span class="token builtin">uint8</span><span class="token comment">// Followed by bucketCnt keys and then bucketCnt elems.</span><span class="token comment">// NOTE: packing all the keys together and then all the elems together makes the</span><span class="token comment">// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span><span class="token comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span><span class="token comment">// Followed by an overflow pointer.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>bmap为固定大小的桶，8个键值对存储；<strong>tophash 存储哈希值高8位<br>编译期间会完善结构 key&#x2F;value 的紧凑结构和overflow的pointer；<br><em>编译期间确定的原因，不确定类型和占用字节的大小；会在构造maptype时确定</em></strong></p><p>具体的架构：</p><p><img src="/image/golang_basic/map_bmap.png" alt="当B为4时具体的图"></p><h3 id="map查找数据的定位方式"><a href="#map查找数据的定位方式" class="headerlink" title="map查找数据的定位方式"></a>map查找数据的定位方式</h3><ul><li>根据key值 和 哈希函数 计算出 哈希值</li><li>按照哈希值 <strong>低B位</strong> 确定对应的哈希桶</li><li>根据哈希值 <strong>高8位 确定位置，tophash对应的值</strong>；</li><li>比较tophash中的值，匹配成功，根据偏移量定位对应的键值；</li><li>找不到，溢出桶中找，直到溢出桶为空</li></ul><h3 id="map-的扩容方式"><a href="#map-的扩容方式" class="headerlink" title="map 的扩容方式"></a>map 的扩容方式</h3><h4 id="渐进式哈希"><a href="#渐进式哈希" class="headerlink" title="渐进式哈希"></a>渐进式哈希</h4><p>根据负载因子（键值数量&#x2F;2^B[桶的个数]），判断是否需要扩容； 装载因子指的是当前map中，每个桶的平均元素个数；</p><p>二倍扩容；避免批量迁移导致大量的操作阻塞，存在性能问题，所以，使用分桶迁移的方式，桶搬迁的时机发生在赋值和删除阶段，每次最多搬迁两个桶；</p><p>在扩容没有完全迁移完成之前，获取数据可能需要查询两个桶，因为部分桶未搬迁；插入，会优先插入新桶中，顺便进行迁移操作，删除同理；</p><h4 id="扩容条件"><a href="#扩容条件" class="headerlink" title="扩容条件"></a>扩容条件</h4><ul><li>装载因子 &gt; 6.5， 平均每个桶的元素个数超过6.5；</li><li>溢出桶的数量过多<ul><li>B &lt; 15，overflow的bucket数量超过 2^B</li><li>B &gt;&#x3D; 15，overflow的bucekt 数量超过 2^15</li></ul></li></ul><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>map 不自动缩容，只有重新赋值&#x2F;nil时才会回收空间；</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang内存管理</title>
    <link href="/2024/03/01/golang/memory/"/>
    <url>/2024/03/01/golang/memory/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h1><p>内存管理的核心目标</p><ul><li>有效的管理系统的内存资源，以提高系统性能、确保程序的正确执行</li><li>最大限度的利用可用的内存空间</li></ul><h2 id="PTmalloc"><a href="#PTmalloc" class="headerlink" title="PTmalloc"></a>PTmalloc</h2><p>glibc（GUN C）默认的内存管理器；内存分配单位为chunk</p><pre><code class="mermaid">graph TD    A(("thread")) --> |"malloc()"|B["加锁分配区"]    B --> C&#123;"chunk_size &lt;= 64B"&#125;    C --> |"yes"|D["在fast bins中分配"]    C --> |"no"|E&#123;"chunk_size &lt; 512B"&#125;    D --> |"失败"|F["small bin中分配"]    E --> |"yes"|F    F --> |"失败"|G["合并fase bin中相邻chunk到unsorted bin中,从中分配"]    G --> |"失败"|H["从large bins中分配"]    E --> |"no"|H    H --> |"失败"|I["从top chunk中分配"]    I --> |"失败"|J&#123;"主分配区？"&#125;    J --> |"否"|L["mmap()增加top chunk或者直接分配"]    J --> |"是"|M["sbrk()增加top chunk或大内存直接mmap()"]</code></pre><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>良好的兼容性，可移植性，稳定性，兼具效率。</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>后分配的内存先释放,因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放, top chunk 以下的 chunk 都无法释放；</li><li>对多线程的支持不好，多线程切换锁的开销较大；</li><li>内存碎片问题，不定期分配长生命周期的内存容易造成内存碎片，不利于回收。</li><li>每个线程都有独立的内存管理空间(arena)，每个arena管理着其线程独有的内存分配与释放。这种设计方式是为了避免不同线程之间的竞争条件，提高并发性能和减少锁的开销。同时也导致了不同线程之间无法共享内存，不能从一个arena移动到另一个arena。如果多线程使用内存不均衡，容易导致内存的浪费；</li></ul><h2 id="TCmalloc-Thread-Caching-malloc"><a href="#TCmalloc-Thread-Caching-malloc" class="headerlink" title="TCmalloc : Thread-Caching malloc"></a>TCmalloc : Thread-Caching malloc</h2><p>tcmalloc是Google开源的一个内存管理库， 作为glibc malloc的替代品。为了多线程并发的内存管理设计的 ，TCmalloc主要是在线程级实现了缓存（Thread Cache），使得用户申请内存时，大多情况是无锁分配。提高了运行的效率</p><p>TCmalloc的三级缓存</p><ol><li><strong>Thread Cache（线程缓存）</strong> ：每个线程都有自己的本地缓存，用于快速分配和释放内存。当线程请求内存分配时，tcmalloc会首先检查线程本地缓存中是否有可用的内存块。这种线程本地缓存机制能够避免多线程竞争，提高内存操作的性能。</li><li><strong>Central Cache（中央缓存）</strong> ：所有线程共享的中央缓存用于存储较大的内存块，它会在多个线程之间共享和重用内存资源。当线程本地缓存不足或未命中时，tcmalloc会尝试从中央缓存中获取可用的内存块，以满足分配请求。</li><li><strong>Page Heap（页堆）</strong> ：页堆是用于存储较大的内存块和未被使用的内存页的地方。当中央缓存无法满足分配请求时，tcmalloc会从页堆中获取更大的内存块，并将其分割为适当大小的块以供分配。</li></ol><p><img src="/image/memory/tcmalloc.png"></p><p>分配流程：</p><ul><li>小对象 &lt;&#x3D;32k：threadCache-&gt;centralCache-&gt;pageHeap-&gt;os</li><li>大对象 &gt;32k: pageHeap-&gt;os</li></ul><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul><li>小内存不加锁分配，提高线程的性能，大内存申请使用自旋锁，更加高效；</li><li>通过缓存和分级管理机制，以及避免不必要的锁竞争来提高系统的可伸缩性</li><li>减少了内存碎片，能够通过内存区块的精细管理和智能分配策略来减少内存碎片的产生，提高内存的利用率，ThreadCache阶段性回收内存到CentralCache中；</li></ul><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>在多线程大内存分配的场景下，自旋锁可能导致系统的CPU暴涨；</li><li>线程本地缓存的内存开销；</li></ul><h2 id="Jemalloc"><a href="#Jemalloc" class="headerlink" title="Jemalloc"></a>Jemalloc</h2><p>jemalloc是facebook开源的内存管理器。具有强大的多核&#x2F;多线程的内存分配能力，对比设计，比ptmalloc，tcmalloc更加复杂。随着硬件发展，锁竞争成为了多核&#x2F;多线程内存分配的最大瓶颈；</p><p>核心概念：</p><ul><li>size_class：代表 jemalloc 分配的内存大小，共有 NSIZES（232）个小类<ul><li>小内存：对于64位机器来说，通常区间是 [8, 14kb]，常见的有 8, 16, 32, 48, 64, …, 2kb, 4kb, 8kb，注意为了减少内存碎片并不都是2的次幂；</li><li>大内存：对于64位机器来说，通常区间是 [16kb, 7EiB]，从 4 * page_size 开始，常见的比如 16kb, 32kb, …, 1mb, 2mb, 4mb</li><li>size_index：size 位于 <code>size_class</code> 中的索引号，区间为 [0，231]，比如8字节则为0，14字节（按16计算）为1，4kb字节为28，当 size 是 <code>small_class</code> 时，<code>size_index</code> 也称作 <code>binind</code></li></ul></li><li>bin：管理正在使用中的 <code>slab</code>（即用于小内存分配的 <code>extent</code>） 的集合，每个 <code>bin</code> 对应一个 <code>size_class</code></li><li>extent：管理 jemalloc 内存块（即用于用户分配的内存）的结构，每一个内存块大小可以是 <code>N * page_size(4kb)</code>（N &gt;&#x3D; 1）。每个 extent 有一个序列号（serial number）。一个 <code>extent</code> 可以用来分配一次 <code>large_class</code> 的内存申请，但可以用来分配多次 <code>small_class</code> 的内存申请。</li><li>slab：当 extent 用于分配 <code>small_class</code> 内存时，称其为 <code>slab</code>。一个 <code>extent</code> 可以被用来处理多个同一 <code>size_class</code> 的内存申请</li><li>area：用于分配&amp;回收 <code>extent</code> 的结构，每个用户线程会被绑定到一个 <code>arena</code> 上，默认每个逻辑 CPU 会有 4 个 <code>arena</code> 来减少锁的竞争，各个 arena 所管理的内存相互独立。<ul><li><code>arena.extents_dirty</code> : 刚被释放后空闲 <code>extent</code> 位于的地方</li><li><code>arena.extents_muzzy</code> : <code>extents_dirty</code> 进行 lazy purge 后位于的地方，<code>dirty -&gt; muzzy</code></li><li><code>arena.extents_retained</code> : <code>extents_muzzy</code> 进行 decommit 或 force purge 后 <code>extent</code> 位于的地方，<code>muzzy -&gt; retained</code></li></ul></li><li>cache_bin：每个线程独有的用于分配小内存的缓存</li><li>tsd：Thread Special Data：每个线程独有，存放有关于这个线程相关的结构结构</li></ul><p>分配流程：</p><ul><li>小内存 &lt;&#x3D;32k：cache_bin -&gt; slab -&gt; slabs_nonfull -&gt; extents_dirty -&gt; extents_muzzy -&gt; extents_retained -&gt; os</li><li>大内存 &gt;32k：extents_dirty -&gt; extents_muzzy -&gt; extents_retained -&gt; os</li></ul><h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><ul><li>多线程下的性能以及内存碎片的减少</li><li>对于保证多线程性能有不同 <code>arena</code>、降低锁的粒度、使用原子语义</li></ul><h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>arena之间内存不可见，导致两个arena的内存出现大量交叉从而无法合并</li><li>额外的内存开销</li></ul><h1 id="golang内存管理"><a href="#golang内存管理" class="headerlink" title="golang内存管理"></a>golang内存管理</h1><p>golang的内存管理就是基于TCMalloc的核心思想来构建的;</p><p><img src="/image/memory/golang_malloc.png"></p><p>span：span是由1个或多个连续Page组成，每个Span对象都有一个起始Page地址以及包含的Page数量。同时Span还有prev和next两个指针，方便组成双向链表。这里的spanClass就是我们上面所说的分级，每个span都只会服务于一种SpanClass。</p><p>sizeClass:</p><ul><li>ObjectSize：是指协程应用逻辑一次向Golang内存申请的对象Object大小。Object是Golang内存管理模块针对内存管理更加细化的内存管理单元。一个Span在初始化时会被分成多个Object。</li><li>SizeClass：一块内存的所属规格或者刻度。Golang内存管理中的Size Class是针对Object Size来划分内存的，划分Object的大小级别；</li><li>SpanClass：针对Span大小级别进行划分的，一个SizeClass会对应两个SpanClass，一个存放需要进行GC扫描的对象（指针对象），另一个不需要进行GC扫描的对象</li></ul><p><img src="/image/memory/span.jpg"></p><p>mcache：线程局部缓存，不需要加锁，作为一个缓存，由0~133多个span-class组成的，里面存放了大量已分配或未分配的Span。当用户程序申请小对象内存时，mcache会查找自己管理的内存块，如果有符合条件的就直接返回，否则向中端请求一批内存来重新填充。 每个mcache绑定一个P，而不是M（局部性原理，避免线程切换带来的开销）</p><p>mcentral：和mcache的组成一样，0~133多个span-class组成的，但每个级别都保存了2个span Set，即2个span集合 1. Partial Span Set ：这个集合里的span，所有span都至少有1个空闲的对象空间。这些span是mcache释放span时加入到该链表的。2. Full Span Set：这个集合里的span，所有的span都不确定里面是否有空闲的对象空间。当一个span交给mcache的时候，就会加入到Full集合中。</p><p>mheap：保存了两棵二叉排序树，按span的page数量进行排序，垃圾回收导致的span释放，span会被加入到scav，否则加入到free：</p><ul><li>free：free中保存的span是空闲并且非垃圾回收的span。</li><li>scav：scav中保存的是空闲并且已经垃圾回收的span。</li></ul><p>mheap中还有arenas，由一组heapArena组成，每一个heapArena都包含了连续的pagesPerArena个span，这个主要是为mheap管理span和垃圾回收服务。mheap本身是一个全局变量，它里面的数据，也都是从OS直接申请来的内存，并不在mheap所管理的那部分内存以内。</p><h2 id="内存分配的过程："><a href="#内存分配的过程：" class="headerlink" title="内存分配的过程："></a>内存分配的过程：</h2><p>针对分配对象的不同大小有不同的分配对象</p><ul><li>（0，16B）且不包含指针的对象：tiny 分配</li><li>（0，16B）包含指针的对象：正常分配</li><li>[16B，32KB]：正常分配</li><li>（32KB，-）：大对象分配</li></ul><p>小对象是在mcache中分配的，而大对象是直接从mheap分配的；</p><p>申请size为n的内存为例子，分配步骤如下：</p><ol><li>获取当前goroutine的私有缓存mcache</li><li>根据size 计算合适class的ID，mcache中有合适大小的span，就分配结束。</li><li>从mcache的alloc[class]链表中查询可用的span</li><li>如果mcache中没有可用的span，则从mcentral申请一个新的span加入mcache中</li><li>如果mcache中也没有可用的span，则从mheap中申请一个新的span加入mcentral</li><li>从该span中获取空闲对象地址并返回。</li></ol><h2 id="内存释放的过程"><a href="#内存释放的过程" class="headerlink" title="内存释放的过程"></a>内存释放的过程</h2><p>Go使用垃圾回收收集不再使用的span，调用mspan.scavenge()把span释放还给OS（并非真释放，只是告诉OS这片内存的信息无用了，如果你需要的话，收回去好了），然后交给mheap，mheap对span进行span的合并，把合并后的span加入scav树中，等待再分配内存时，由mheap进行内存再分配；</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sysmon线程</title>
    <link href="/2024/03/01/golang/sysmon/"/>
    <url>/2024/03/01/golang/sysmon/</url>
    
    <content type="html"><![CDATA[<h2 id="sysmon-线程"><a href="#sysmon-线程" class="headerlink" title="sysmon 线程"></a>sysmon 线程</h2><p>执行 <code>runtime_init()</code> 之前启动一个监控线程，执行后台监控任务；</p><p><code>sysmon</code> 不依赖P直接执行，通过newm创建一个工作线程；</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>执行一个无限循环，每次休眠20us，之后（1ms后）每次休眠时间倍增，最终每一轮休眠10ms；</li><li>周期性的进行netpool（获取fd事件），retake（抢占），forcegc（按照时间执行gc），scavenge heap（释放自由列表的内存，减少内存占用）等处理；</li></ul><h2 id="retake系统调度（抢占式调度）"><a href="#retake系统调度（抢占式调度）" class="headerlink" title="retake系统调度（抢占式调度）"></a>retake系统调度（抢占式调度）</h2><h3 id="抢占进行系统调用的P"><a href="#抢占进行系统调用的P" class="headerlink" title="抢占进行系统调用的P"></a>抢占进行系统调用的P</h3><p>当P处于 <code>_Psyscall</code> 状态时，表明对应的goroutine正在进行系统调用，如果抢占P，需要<strong>满足对应的条件中的****一个</strong>：</p><ul><li>p的本地队列里面有等待运行的goroutine；这是p绑定的g正在进行系统调用，无法去执行其他的g，需要接管p执行其他的g；</li><li>没有 空闲的p，<code>sched.nmspinning</code> 和 <code>sched.npidle</code> 都为 0，这就意味着没有“找工作”的 m，也没有空闲的 p，大家都在“忙”，可能有很多工作要做。因此要抢占当前的 p，让它来承担一部分工作。</li><li>从上一次监控线程观察到 p 对应的 m 处于系统调用之中到现在已经超过 10 毫秒。这说明系统调用所花费的时间较长，需要对其进行抢占，以此来使得 <code>retake</code> 函数返回值不为 0，这样，会保持 sysmon 线程 20 us 的检查周期，提高 sysmon 监控的实时性。</li></ul><p>确定抢占后，使用原子操作将P的状态修改为 <code>_Pidle</code> ，最后调用handoffp进行抢占；<br><code>handoffp</code> 进行场景判断，调用 <code>startm</code> 启动一个工作线程来绑定P，使得工作继续推进；</p><h3 id="抢占执行时间过长的P上的G"><a href="#抢占执行时间过长的P上的G" class="headerlink" title="抢占执行时间过长的P上的G"></a>抢占执行时间过长的P上的G</h3><p>Go scheduler 采用的是一种称为协作式的抢占式调度，就是说并不强制调度，大家保持协作关系，互相信任。对于长时间运行的 P，或者说绑定在 P 上的长时间运行的 goroutine，sysmon 会检测到这种情况，然后设置一些标志，表示 goroutine 自己让出 CPU 的执行权，给其他 goroutine 一些机会。</p><p>接下来我们就来分析当 P 处于 <code>_Prunning</code> 状态的情况。<code>sysmon</code> 扫描每个 p 时，都会记录下当前调度器调度的次数和当前时间，数据记录在结构体：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> sysmintick <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>schedtick   <span class="token builtin">uint32</span> <span class="token comment">// 调度器次数</span>schedwhen   <span class="token builtin">int64</span>  <span class="token comment">// 调度器时间</span>syscalltick <span class="token builtin">uint32</span> <span class="token comment">// 系统调用次数</span>syscallwhen <span class="token builtin">int64</span>  <span class="token comment">// 系统调用时间</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>前面两个字段记录调度器调度的次数和时间，后面两个字段记录系统调用的次数和时间。</p><p>在下一次扫描时，对比 sysmon 记录下的 p 的调度次数和时间，与当前 p 自己记录下的调度次数和时间对比，如果一致。说明 P 在这一段时间内一直在运行同一个 goroutine。那就来计算一下运行时间是否太长了。</p><p>运行时间超过10ms，需要调用 <code>preemptone(_p_)</code> 发起抢占请求；给其他goroutine运行的机会；</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go-schedule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>innodb 自增锁</title>
    <link href="/2024/03/01/mysql/incr/"/>
    <url>/2024/03/01/mysql/incr/</url>
    
    <content type="html"><![CDATA[<h1 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO_INC 锁"></a>AUTO_INC 锁</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>表级锁，如果一张表中有自增的列（例如： <code>id</code> int NOT NULL AUTO_INCREMENT,）那么当向这张表插入数据时，InnoDB会先获取这张表的AUTO-INC锁。</p><p>如果一个事务正在插入数据到有自增列的表时，其他事务会阻塞等待正在持有AUTO-INC锁的事务释放AUTO-INC锁。</p><h2 id="自增分类"><a href="#自增分类" class="headerlink" title="自增分类"></a>自增分类</h2><h3 id="insert-like-语句"><a href="#insert-like-语句" class="headerlink" title="insert-like 语句"></a>insert-like 语句</h3><p>所有的插入语句，包括：insert，insert … select（复制语句），replace into，replace … select，load data等；</p><h3 id="simple-inserts"><a href="#simple-inserts" class="headerlink" title="simple inserts"></a>simple inserts</h3><p>插入前就能确定行数的语句，包含：insert，replace，不包含 insert … on duplicate key update 这类语句；</p><h3 id="bulk-inserts"><a href="#bulk-inserts" class="headerlink" title="bulk inserts"></a>bulk inserts</h3><p>插入前无法确定行数的语句，包含 :insert … select&#x2F;replace … select&#x2F;load data;</p><h3 id="Mixed-mode-inserts"><a href="#Mixed-mode-inserts" class="headerlink" title="Mixed-mode inserts"></a>Mixed-mode inserts</h3><p>混合模式分两种：</p><ol><li>插入的语句有一些自增列时确定的值，一些是不确定的。(c1自增列)<br><code> INSERT INTO t1(c1, v2) VALUES (1,&#39;a&#39;), (NULL, &#39;b&#39;), (5, &#39;c&#39;);</code></li><li>insert … on duplicate key update<br>使用锁来为AUTO_INCREMENT 分配自增值，更新阶段可能不用</li></ol><h2 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h2><p>innodb_autoinc_lock_mode 变量配置自增锁的算法；</p><table><thead><tr><th align="center">innodb_autoinc_lock_mode</th><th align="center">变量含义</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">传统锁模式</td></tr><tr><td align="center">1</td><td align="center">连续锁模式</td></tr><tr><td align="center">2</td><td align="center">交错锁模式（mysql8默认）</td></tr></tbody></table><h3 id="传统锁模式"><a href="#传统锁模式" class="headerlink" title="传统锁模式"></a>传统锁模式</h3><p>在传统锁模式下，所有的”INSERT-LIKE”语句为AUTO_INCREMENT列使用表级AUTO_INC锁。 <strong>一个事务的”INSERT-LIKE”语句在语句执行结束后释放AUTO_INC表级锁，而不是在事务结束后释放</strong> 。（优化并发性能）这样做的目的是为了保证这个”INSERT-LIKE”语句的自增列的值是连续的。</p><h3 id="连续锁模式"><a href="#连续锁模式" class="headerlink" title="连续锁模式"></a>连续锁模式</h3><p>连续锁模式对于 simple inserts 不会使用表级锁，而是使用一个轻量级的锁来生成自增值，因为InnoDB可以提前直到插入多少行数据。自增值生成阶段使用轻量级互斥锁来生成所有的值，而不是一直加锁直到插入完成。但是如果其他事务持有AUTO_INC锁，那么“Simple Inserts”类语句也需要等待其他事务完成才能使用轻量级锁来生成所有的自增值。</p><p>连续锁模式使用 bulk inserts 类语句使用 AUTO_INC <strong>表级锁直到语句完成</strong>；</p><p>当innodb_autoinc_lock_mode&#x3D;1时，在语句复制格式下(BINLOG_FORMAT&#x3D;<strong>STATEMENT</strong>)，BINLOG中没有记录主库执行过程中获取到的所有自增值及其对应行的信息，要保证”Bulk insert”操作主从复制数据一致就必须保证语句在主库和从库执行时获取到相同自增值，而因此只能通过控制“获取连续自增值”的方式来实现，同时为避免受其他事务插入操作影响，就必须在表级别加锁且保证持有锁至语句结束。</p><p>在行复制格式下(BINLOG_FORMAT&#x3D;<strong>ROW</strong>)，主库BINLOG中保存有记录的所有列信息包括自增列值，因此无需通过AUTO-INC锁来保证主从数据一致。在MySQL 8.0版本前，参数BINLOG_FORMAT的默认值为STATEMENT，参数innodb_autoinc_lock_mode的默认值为1。在MySQL 8.0版本后，参数BINLOG_FORMAT的默认值被调整为ROW格式，参数innodb_autoinc_lock_mode的默认值为2。</p><h3 id="交错锁模式"><a href="#交错锁模式" class="headerlink" title="交错锁模式"></a>交错锁模式</h3><p>所有的 insert-like 都不使用表级锁，而是使用轻量级互斥锁</p><p>交错锁模式速度快、可扩展性高，但是对于基于语句复制会有问题，只能使用基于ROW复制。</p><p>之所以称为交错模式是因为并发插入场景下自增值的分配大概率是交替这来的，时刻1事务1获得自增值，时刻2事务2获得自增值，以此类推。</p><h2 id="自增值丢失-和-间隙"><a href="#自增值丢失-和-间隙" class="headerlink" title="自增值丢失 和 间隙"></a>自增值丢失 和 间隙</h2><p>因为大部分情况下，自增锁使用都是在insert 结束后就释放，无论事务是否提交；所以当如果一个插入数据的事务回滚，那么为这个事务生成的自增值就会丢失，因为自增值不会回滚；<br>回滚造成的自增值丢失InnoDB是不会被重用，所以不能依赖InnoDB<strong>自增列是连续值</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>mutex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引</title>
    <link href="/2024/03/01/mysql/index/"/>
    <url>/2024/03/01/mysql/index/</url>
    
    <content type="html"><![CDATA[<h1 id="索引定义"><a href="#索引定义" class="headerlink" title="索引定义"></a>索引定义</h1><p>索引（Index）是提高数据库查询效率的工具，本质上是一个排序的数据结构，存储了表中某些列的值和对应的行号（引用）。</p><p>索引可以加速数据检索，但会增加数据插入、更新和删除的开销。</p><p>可以简单理解为目录，用于提取特征，快速检索使用的；</p><blockquote><p><strong>典型的利用空间换时间的一个应用；</strong></p></blockquote><h1 id="索引作用"><a href="#索引作用" class="headerlink" title="索引作用"></a>索引作用</h1><ul><li>加快查询速度（核心），显著提升性能</li><li>辅助约束：主键索引（Primary），唯一索引（Unique）</li><li>提高排序效率，有索引字段排序会更快（索引有序）</li></ul><h1 id="MYSQL索引分类"><a href="#MYSQL索引分类" class="headerlink" title="MYSQL索引分类"></a>MYSQL索引分类</h1><h2 id="物理结构区分"><a href="#物理结构区分" class="headerlink" title="物理结构区分"></a>物理结构区分</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><ul><li>数据存储顺序和索引顺序一致</li><li>数据行和索引行存储在一起</li><li>主键索引默认聚簇索引</li><li>每个表只能有一个聚簇索引</li><li>适合范围查询</li></ul><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><ul><li>数据存储顺序和索引顺序不一致</li><li>数据行和索引行存储在不同的地方</li><li>可以有多个非聚簇索引</li></ul><h2 id="数据结构区分"><a href="#数据结构区分" class="headerlink" title="数据结构区分"></a>数据结构区分</h2><h3 id="B树类结构（B树，B-树）"><a href="#B树类结构（B树，B-树）" class="headerlink" title="B树类结构（B树，B+树）"></a>B树类结构（B树，B+树）</h3><p>查询数据不需要全表扫描，从索引的树根节点开始进行搜索，根节点存放了子节点的指针，继续向下层查找；</p><ul><li>B树：每个节点可以有多个子节点，数据存储在每个节点上，适合频繁的插入和删除操作；</li><li>B+树：每个节点可以有多个子节点，适合范围查询，数据存储在叶子节点，非叶子节点只存放索引值和指向子节点的指针；所有数据都在叶子节点上，叶子节点之间有链表连接，方便范围查询；</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>查询效率：<ul><li>B树：B树每个节点都存储数据，查询效率可能从 O(1) ~ O(logN)</li><li>B+树：只有叶子节点存储数据，查询效率O(logN)</li></ul></li><li>区间访问效率：<ul><li>B树：B树的每个节点key和data节点相连，无法直接区间查找</li><li>B+树：B+树的叶子节点之间有链表连接，可以直接区间查找</li></ul></li><li>场景：<ul><li>B树：内存数据库，快速定位记录，节点更新频繁</li><li>B+树：更适合外部存储，因为data和index分离，可以让索引部分更小，减少IO次数，能够检索的范围更大，查询效率更加稳定</li></ul></li></ul><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>等值查询，将索引值通过哈希函数转化为哈希码（hash code），将hash码保存在索引中，MySQL中的内存表和MyISAM存储引擎支持哈希索引</p><h3 id="R-Tree索引"><a href="#R-Tree索引" class="headerlink" title="R-Tree索引"></a>R-Tree索引</h3><p>空间数据索引的数据结构，广泛应用于地理信息系统（GIS）和空间数据库中。<br>它是一种多维的平衡搜索树，旨在高效地存储和查询包含多个维度的空间数据。</p><h3 id="FULLTEXT索引"><a href="#FULLTEXT索引" class="headerlink" title="FULLTEXT索引"></a>FULLTEXT索引</h3><p>全文索引，查找文本关键字，而不是索引的值，和BTree索引不会冲突；MyISAM或InnoDB存储引擎支持，只支持char, varchar, text类型字段使用</p><h1 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h1><ul><li>主键索引：聚簇索引，不允许空值</li><li>唯一索引：唯一性，允许空值</li><li>普通索引：没有唯一性要求，提高查询效率</li><li>前缀索引：对于字符串类型的前几个字符建立索引，而不是整个字段上建立索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</li><li>组合索引：多个字段创建的索引，遵守<font color=Red><strong>最左匹配原则</strong></font><ul><li>底层：按照（字段1，字段2，字段3）排序的B+树</li></ul></li><li>全文索引：全局模糊搜索</li><li>空间索引：用于GIS地理数据的索引</li></ul><h1 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h1><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>a,b,c列建立联合索引，当查询条件不包含a时，无法使用联合索引加速查找；（包含a，优化器会根据索引优化判断是否使用联合索引）</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>覆盖索引是指查询的字段都在索引中，避免回表查询数据，提升查询效率；（索引字段和查询字段一致）</p><h3 id="索引下推（Index-Condition-PushDown"><a href="#索引下推（Index-Condition-PushDown" class="headerlink" title="索引下推（Index Condition PushDown)"></a>索引下推（Index Condition PushDown)</h3><p>索引下推是指在使用索引时，<font color=red><strong>MySQL会在索引中进行初步过滤，减少回表的行数，从而提高查询效率</strong></font>；</p><p><strong>查询流程：</strong></p><table><thead><tr><th align="center">情况</th><th align="center">流程</th></tr></thead><tbody><tr><td align="center">未使用ICP</td><td align="center">1. 存储引擎读取索引记录<br/>2.根据索引中的主键ID，获取完整的行记录<br/>3.存储引擎将记录读取交给Server层检测是否满足条件</td></tr><tr><td align="center">使用ICP</td><td align="center">1.存储引擎读取索引记录（非完整的行记录）<br/>2.判断where条件是否能使用索引中的列检查，条件不满足处理下一条<br/>3.条件满足。使用索引中主键定位记录（回表）<br/>4.存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的其余部分。</td></tr></tbody></table><p>目的：</p><ul><li>减少回表次数，减少IO操作，对于聚簇索引（主键索引），不存在回表</li></ul><p><strong>使用条件</strong>： ICP 只能在走“基于索引的行访问”场景中触发</p><ul><li>只能用于 range(范围查询), ref(单个索引等值查询), eq_ref(唯一索引等值连接), ref_or_null(等值+NULL判断) 访问方法</li><li>只能用于 <code>innodb, myisam</code> 存储引擎</li><li>对<code>InnoDB</code>存储引擎来说，索引下推只适用于二级索引（也叫辅助索引）</li></ul><p><font color=Red>查看是否使用了ICP：</font><br><code>explain select ...</code> 看Extra列是否出现:Using index condition</p><p>NOTE：</p><ol><li>引用了子查询的条件不能下推</li><li>引用了存储函数的条件不能下推，存储引擎无法调用存储函数</li></ol><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><p>可能引起索引失效的场景</p><ul><li>查询数据，查询条件中存在函数，运算，or（没有全走索引），not，is not，!&#x3D;，&lt;&gt;等</li><li>组合索引，没有遵循最左匹配原则</li><li>查询的数据超过总数的 30%（优化器觉得扫描全表更快）</li><li>查询条件使用 like （%开头），不使用索引</li><li>存在隐式转换（varchar to bigint）</li></ul><h3 id="推荐使用索引"><a href="#推荐使用索引" class="headerlink" title="推荐使用索引"></a>推荐使用索引</h3><ul><li>唯一性约束</li><li>频繁WHERE查询的字段</li><li>经常GROUP BY和ORDER BY的字段</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>不推荐使用索引</p><ul><li>数据唯一性差 – 时机需求</li><li>频繁更新的字段不要使用索引 – 会导致额外的更新开销</li><li>字段不在where语句出现时不要添加索引,如果where后含IS NULL &#x2F;IS NOT NULL&#x2F; like ‘%输入符%’等条件，不建议使用索引</li><li>where 子句里对索引列使用不等于（&lt;&gt;），使用索引效果一般</li></ul><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><ul><li>前缀索引优化</li><li>主键自增：减少聚簇索引构建的代价，增加插入效率，减少内存碎片</li><li>索引设置：Not NULL，减小行存储和 减少优化器的索引选择</li></ul><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p><strong>延迟关联（深分页优化）（SQL优化中的）</strong></p><p><strong>查询优化技术，可以推迟执行关联操作，延迟关联的执行时间，从而提高查询性能</strong><br>允许服务器在不访问行的情况下检查索引中尽可能少的数据（覆盖索引的使用）。找到所需的行，和表联接，通过行检索其他列；<br>减少回表，将查询条件集中在辅助索引中，减少辅助索引返回的结果；</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>index</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库锁</title>
    <link href="/2024/03/01/mysql/mutex/"/>
    <url>/2024/03/01/mysql/mutex/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>锁是数据库管理系统中用于控制对数据库对象的访问的一种机制。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>它可以防止多个事务同时修改同一数据，从而确保数据的一致性和完整性。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="按照锁的粒度"><a href="#按照锁的粒度" class="headerlink" title="按照锁的粒度"></a>按照锁的粒度</h3><ul><li>行锁<ul><li>粒度最小的锁，只对于当前操作的行进行锁定</li><li>能够大大减少数据库操作的冲突</li><li>粒度小，意味着性能好（并发度高）</li><li>加锁的开销大（找到指定的行），加锁慢</li></ul></li><li>表锁：<ul><li>粒度最大的锁，锁定整张表</li><li>加锁开销小（只需要找到表），加锁快</li><li>性能低</li></ul></li><li>页锁：(mysql innodb 不支持页锁，sql sever的特性)<ul><li>粒度介于行锁和表锁之间</li><li>表锁速度快，但是冲突多，行锁冲突少，但速度慢；取这种的页锁，一次锁定相邻的一组记录； 开销介于两者之间，可能出现死锁；并发度一般</li></ul></li></ul><p><font color=Red><strong>表锁和行锁是满足读读共享、读写互斥、写写互斥的</strong></font></p><h3 id="按照锁的性质"><a href="#按照锁的性质" class="headerlink" title="按照锁的性质"></a>按照锁的性质</h3><ul><li>共享锁<ul><li>S锁，读锁，用于所有的只读操作；</li><li>允许多个事务向同一资源加锁；</li><li>加S锁的同步不能加X锁，资源不能被修改；</li><li>S锁读取结束立即释放，不需要等待事务结束；</li></ul></li><li>排他锁<ul><li>X锁，写锁，用于所有的写操作；</li><li>允许一个事务对于同一资源加锁，知道事务结束释放；</li><li>其他任何事务需要等待X锁释放才能访问；</li></ul></li><li>更新锁<ul><li>U锁，更新锁，介于S锁和X锁之间；</li><li>开始作为共享锁允许数据读取，当确定要去更改数据时，会自动升级为排他锁</li><li>设计得更精细，用于防止多个同时读取并可能修改数据的事务导致的死锁</li></ul></li><li>意向锁（表级锁）<ul><li>IX（意向排他），IS（意向共享），为了协调表锁和行锁之间的关系，支持多粒度的锁并行（行锁，表锁）</li><li>IS锁（意向共享锁），事务在请求S锁之前，先请求IS锁，表示当前事务打算对表中的某些行加S锁；</li><li>IX锁（意向排他锁），事务在请求X锁之前，先请求IX锁，表示当前事务打算对表中的某些行加X锁；</li><li>意向锁是表级锁，意向锁和行级锁可以并存；</li><li>意向锁的作用是为了提高锁的性能，避免在加<font color='red'><strong>表锁</strong></font>时需要遍历整个表；快速的判断 X，S锁，提升性能；</li></ul></li></ul><p>意向锁兼容情况：</p><table><thead><tr><th>锁</th><th>IS</th><th>IX</th><th>S</th><th>X</th></tr></thead><tbody><tr><td>IS</td><td>✅兼容</td><td>✅兼容</td><td>✅兼容</td><td>冲突</td></tr><tr><td>IX</td><td>✅兼容</td><td>✅兼容</td><td>冲突</td><td>冲突</td></tr><tr><td>S</td><td>✅兼容</td><td>冲突</td><td>✅兼容</td><td>冲突</td></tr><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr></tbody></table><ol><li>意向锁之间是兼容的</li><li>X锁和所有锁冲突</li></ol><ul><li><font color='RED'><strong>特殊的意向锁（行级锁）</strong>：插入意向锁（insert intention lock）</font><ul><li>本质和作用<ul><li>本质是特殊的Gap Lock，为了 INSERT设计</li><li>保证不出现&lt;幻读&gt;的情况下，最大化插入的并发</li></ul></li><li>加锁规则<ul><li>仅在<strong>RR（可重复读）</strong>隔离级别下生效</li><li>先尝试获取目标间隙的普通Gap Lock，再转换为Insert Intention Lock</li><li>如果间隙已被其他事务加普通Gap Lock，则阻塞等待</li></ul></li><li>和Gap Lock区别<ul><li>加锁场景<ul><li>Gap Lock:for update</li><li>insert intent Lock: insert</li></ul></li><li>是否阻塞其他插入<ul><li>Gap Lock:是</li><li>insert intent Lock: 唯一键不同不阻塞</li></ul></li><li>兼容性<ul><li>Gap Lock:互斥</li><li>insert intent Lock: 允许多个事务持有</li></ul></li></ul></li></ul></li></ul><h3 id="主观划分"><a href="#主观划分" class="headerlink" title="主观划分"></a>主观划分</h3><ul><li>乐观锁<ul><li>主观锁，假设不会发生冲突，先执行操作，最后检查是否发生冲突；</li></ul></li><li>悲观锁<ul><li>排他锁，假设每次读取数据都任务会修改资源，每次操作都需要加锁；</li></ul></li></ul><h2 id="Innodb的锁"><a href="#Innodb的锁" class="headerlink" title="Innodb的锁"></a>Innodb的锁</h2><p>表中即使没有索引，InnoDB也会创建隐藏的聚簇索引</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul><li>行锁是InnoDB的默认锁，粒度最小的锁；</li><li>行锁是通过索引来实现的，只有在有索引的情况下才能加行锁；</li><li>行锁是通过记录锁和间隙锁来实现的；</li></ul><h4 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h4><ul><li>记录锁是对索引记录加锁，锁定一行数据；</li></ul><h4 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h4><ul><li>间隙锁是对索引记录之间的间隙加锁，锁定一段范围；</li></ul><h4 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h4><ul><li>Next-Key Lock是记录锁和间隙锁的结合，锁定一行数据和它前面的间隙；</li><li>是一个前闭后开的模型</li><li><code>where id &gt; 18 AND id &lt; 20</code> 会锁定 (18,20)的区间对应的间隙锁+范围内存在的记录，不包含id&#x3D;20;<ul><li>当id为（10, 15, 18, 22）时，会锁住 (18, 22]</li></ul></li></ul><p>查询的索引具有唯一属性时，将Next-Key Lock降级为 Record Lock<br><font color=Red><strong>Gap Lock和 Next-Key Lock是可重复读场景下，解决幻读问题的锁</strong></font></p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul><li>表锁是InnoDB的默认锁，粒度最大的锁；</li><li>表锁是通过表级锁来实现的，锁定整张表；</li></ul><p>命令 <code>lock table</code> 和 <code>unlock table</code> 来加锁和解锁表；</p><h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a><font color='RED'><strong>快照读和当前读</strong></font></h3><ul><li>快照读：不加锁，读取数据的快照，不加锁的简单select都属于快照读;</li><li>当前读：加锁，读取数据的最新值，当前读会加锁，阻塞其他事务的操作；<ul><li>in share mode(S锁)</li><li>for update(X锁)</li><li>update&#x2F;delete 操作默认使用当前读</li></ul></li></ul><h2 id="Innodb锁的实现"><a href="#Innodb锁的实现" class="headerlink" title="Innodb锁的实现"></a>Innodb锁的实现</h2><h3 id="索引类型对锁的影响"><a href="#索引类型对锁的影响" class="headerlink" title="索引类型对锁的影响"></a>索引类型对锁的影响</h3><table><thead><tr><th><strong>索引类型</strong></th><th><strong>加锁行为</strong></th><th><strong>示例场景</strong></th></tr></thead><tbody><tr><td><strong>主键&#x2F;唯一索引</strong></td><td>仅锁定具体行（Record Lock）</td><td><code>UPDATE users SET name=&#39;A&#39; WHERE id=1</code></td></tr><tr><td><strong>普通二级索引</strong></td><td>先锁二级索引记录，再回表锁主键记录（可能加Gap Lock）</td><td><code>UPDATE users SET score=100 WHERE age&gt;20</code></td></tr><tr><td><strong>无索引</strong></td><td>全表扫描，升级为表锁（实际对所有行加Record Lock+间隙锁，性能极差）</td><td><code>UPDATE users SET status=1 WHERE name LIKE &#39;%abc%&#39;</code></td></tr></tbody></table><h3 id="关键规则"><a href="#关键规则" class="headerlink" title="关键规则"></a>关键规则</h3><ol><li><strong>锁升级条件</strong>：当SQL无法通过索引精确定位数据时，可能从行锁升级为表锁。</li><li><strong>覆盖索引优化</strong>：使用覆盖索引可避免回表加锁（仅锁二级索引）。</li></ol><h3 id="加锁规则速查表"><a href="#加锁规则速查表" class="headerlink" title="加锁规则速查表"></a>加锁规则速查表</h3><table><thead><tr><th><strong>SQL类型</strong></th><th><strong>隔离级别</strong></th><th><strong>加锁方式</strong></th></tr></thead><tbody><tr><td><code>SELECT ...</code></td><td>READ COMMITTED</td><td>不加锁（快照读）</td></tr><tr><td><code>SELECT ... LOCK IN SHARE MODE</code></td><td>所有级别</td><td>对扫描行加S锁（当前读）</td></tr><tr><td><code>SELECT ... FOR UPDATE</code></td><td>所有级别</td><td>对扫描行加X锁 + 相关间隙加Gap Lock（RR级别）</td></tr><tr><td><code>UPDATE/DELETE</code></td><td>所有级别</td><td>对修改行加X锁 + 相关间隙锁（RR级别）</td></tr><tr><td><code>INSERT</code></td><td>所有级别</td><td>对目标间隙加Insert Intention Lock + 插入行加X锁</td></tr></tbody></table><h3 id="特殊场景"><a href="#特殊场景" class="headerlink" title="特殊场景"></a>特殊场景</h3><ul><li><strong>INSERT ON DUPLICATE KEY UPDATE</strong>：先尝试加Insert Intention Lock，冲突时转为X锁</li><li><strong>REPLACE INTO</strong>：等效于先DELETE后INSERT，会加X锁和间隙锁</li></ul><h2 id="锁监控-优化"><a href="#锁监控-优化" class="headerlink" title="锁监控&#x2F;优化"></a>锁监控&#x2F;优化</h2><h3 id="锁监控命令"><a href="#锁监控命令" class="headerlink" title="锁监控命令"></a>锁监控命令</h3><figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查看锁等待关系（MySQL 5.7）</span><span class="token keyword">SELECT</span>   r<span class="token punctuation">.</span>trx_id <span class="token keyword">AS</span> waiting_trx_id<span class="token punctuation">,</span>  r<span class="token punctuation">.</span>trx_mysql_thread_id <span class="token keyword">AS</span> waiting_thread<span class="token punctuation">,</span>  b<span class="token punctuation">.</span>trx_id <span class="token keyword">AS</span> blocking_trx_id<span class="token punctuation">,</span>  b<span class="token punctuation">.</span>trx_mysql_thread_id <span class="token keyword">AS</span> blocking_thread<span class="token punctuation">,</span>  l<span class="token punctuation">.</span>lock_table <span class="token keyword">AS</span> locked_table<span class="token punctuation">,</span>  l<span class="token punctuation">.</span>lock_index <span class="token keyword">AS</span> locked_index<span class="token punctuation">,</span>  l<span class="token punctuation">.</span>lock_type <span class="token keyword">AS</span> lock_type<span class="token punctuation">,</span>  l<span class="token punctuation">.</span>lock_mode <span class="token keyword">AS</span> lock_mode<span class="token keyword">FROM</span> sys<span class="token punctuation">.</span>innodb_lock_waits w<span class="token keyword">JOIN</span> information_schema<span class="token punctuation">.</span>innodb_trx b <span class="token keyword">ON</span> b<span class="token punctuation">.</span>trx_id <span class="token operator">=</span> w<span class="token punctuation">.</span>blocking_trx_id<span class="token keyword">JOIN</span> information_schema<span class="token punctuation">.</span>innodb_trx r <span class="token keyword">ON</span> r<span class="token punctuation">.</span>trx_id <span class="token operator">=</span> w<span class="token punctuation">.</span>requesting_trx_id<span class="token keyword">JOIN</span> information_schema<span class="token punctuation">.</span>innodb_locks l <span class="token keyword">ON</span> w<span class="token punctuation">.</span>requested_lock_id <span class="token operator">=</span> l<span class="token punctuation">.</span>lock_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查看当前锁等待（MySQL 8.0+）</span><span class="token keyword">SELECT</span>   r<span class="token punctuation">.</span>trx_id <span class="token keyword">AS</span> waiting_trx_id<span class="token punctuation">,</span>  r<span class="token punctuation">.</span>trx_mysql_thread_id <span class="token keyword">AS</span> waiting_thread<span class="token punctuation">,</span>  b<span class="token punctuation">.</span>trx_id <span class="token keyword">AS</span> blocking_trx_id<span class="token punctuation">,</span>  b<span class="token punctuation">.</span>trx_mysql_thread_id <span class="token keyword">AS</span> blocking_thread<span class="token punctuation">,</span>  l<span class="token punctuation">.</span>object_name <span class="token keyword">AS</span> locked_table<span class="token punctuation">,</span>  l<span class="token punctuation">.</span>index_name <span class="token keyword">AS</span> locked_index<span class="token punctuation">,</span>  l<span class="token punctuation">.</span>lock_type <span class="token keyword">AS</span> lock_type<span class="token punctuation">,</span>  l<span class="token punctuation">.</span>lock_mode <span class="token keyword">AS</span> lock_mode<span class="token keyword">FROM</span> performance_schema<span class="token punctuation">.</span>data_lock_waits w<span class="token keyword">JOIN</span> information_schema<span class="token punctuation">.</span>innodb_trx b <span class="token keyword">ON</span> b<span class="token punctuation">.</span>trx_id <span class="token operator">=</span> w<span class="token punctuation">.</span>blocking_engine_transaction_id<span class="token keyword">JOIN</span> information_schema<span class="token punctuation">.</span>innodb_trx r <span class="token keyword">ON</span> r<span class="token punctuation">.</span>trx_id <span class="token operator">=</span> w<span class="token punctuation">.</span>requesting_engine_transaction_id<span class="token keyword">JOIN</span> performance_schema<span class="token punctuation">.</span>data_locks l <span class="token keyword">ON</span> w<span class="token punctuation">.</span>requesting_engine_lock_id <span class="token operator">=</span> l<span class="token punctuation">.</span>engine_lock_id<span class="token punctuation">;</span><span class="token comment">-- 查看所有持有锁的事务（MySQL 8.0+）</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> performance_schema<span class="token punctuation">.</span>data_locks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW ENGINE INNODB STATUS; -- 查看死锁日志<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>查询语句<br><img src="/image/mysql/mutex-search-for-update.png"></p><p>查看锁等待语句<br><img src="/image/mysql/mutex-search.png"></p><h3 id="关键字段"><a href="#关键字段" class="headerlink" title="关键字段"></a>关键字段</h3><ul><li>locked_index:锁作用的索引</li><li>locked_mode：X&#x2F;S&#x2F;IX&#x2F;IS模式</li><li>lock_type：行锁（RECORD）或表锁（TABLE）</li></ul><h3 id="避免锁争用的最佳实践"><a href="#避免锁争用的最佳实践" class="headerlink" title="避免锁争用的最佳实践"></a><strong>避免锁争用的最佳实践</strong></h3><table><thead><tr><th><strong>问题类型</strong></th><th><strong>解决方案</strong></th></tr></thead><tbody><tr><td><strong>长事务阻塞</strong></td><td>监控<code>information_schema.innodb_trx</code>，kill长时间运行的事务（&gt;60s）</td></tr><tr><td><strong>无索引导致表锁</strong></td><td>为WHERE条件添加索引（尤其高频更新字段）</td></tr><tr><td><strong>热点行争用</strong></td><td>使用队列化处理或应用层缓存减少并发更新</td></tr><tr><td><strong>间隙锁冲突</strong></td><td>在RR级别下，尽量使用等值查询而非范围查询</td></tr></tbody></table><h3 id="配置调优"><a href="#配置调优" class="headerlink" title="配置调优"></a>配置调优</h3><figure><div class="code-wrapper"><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token comment"># my.cnf关键参数</span><span class="token key attr-name">innodb_lock_wait_timeout</span><span class="token punctuation">=</span><span class="token value attr-value">50       # 锁等待超时时间（秒）</span><span class="token key attr-name">innodb_deadlock_detect</span><span class="token punctuation">=</span><span class="token value attr-value">ON         # 死锁检测（高并发时可临时关闭）</span><span class="token key attr-name">transaction_isolation</span><span class="token punctuation">=</span><span class="token value attr-value">READ-COMMITTED  # 降低隔离级别减少加锁范围</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="终止事务"><a href="#终止事务" class="headerlink" title="终止事务"></a>终止事务</h3><figure><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * FROM information_schema.innodb_trx;kill &lt;trx_id&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>mutex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开始</title>
    <link href="/2023/10/16/start/"/>
    <url>/2023/10/16/start/</url>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>为了记录自己所学的知识</p><p>为了记录自己遇到的问题</p><p>为了总结处理问题的方法</p><p>为了构建自己的知识体系</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul><li>现在是什么水平？</li><li>想要达到什么水平？</li><li>如何达到那个水平？</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
